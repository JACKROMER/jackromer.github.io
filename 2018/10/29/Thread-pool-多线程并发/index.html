<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.8.0">

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="Jack Romer&#39;s blog">
    

    <!--Author-->
    
        <meta name="author" content="Jack Romer">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="Thread-pool-多线程并发">
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="Jack Romer&#39;s blog">
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="Jack Romer welcome ...">

    <!--Type page-->
    
        <meta property="og:type" content="article">
    

    <!--Page Cover-->
    

    <meta name="twitter:card" content="summary">
    

    <!-- Title -->
    
    <title>Thread-pool-多线程并发 - Jack Romer welcome ...</title>

    <!-- Tachyons Core CSS -->
    <link rel="stylesheet" href="//unpkg.com/tachyons/css/tachyons.min.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Google Analytics -->
    


</head>


<body>

<!-- Main Content -->
<!-- Banner -->
<!-- Banner -->
<div class="w-100 bg-1 ph5-ns ph3 text-light">
    
    <nav class="db dt-l w-100 mw8 center border-box pv3">
        <a class="db dtc-l v-mid link dim w-100 w-25-l tc tl-l mb2 mb0-l white" href="/" title="Jack Romer welcome ...">
            <img src="/images/mine.jpg" class="dib h3" alt="Jack Romer welcome ...">
        </a>
        <div class="db dtc-l v-mid w-100 w-75-l tc tr-l">
            
                <a class="link dim f6 f5-l dib mr3 mr4-l white" href="/" title="主页">
                    主页
                </a>
            
                <a class="link dim f6 f5-l dib mr3 mr4-l white" href="/archives" title="归档">
                    归档
                </a>
            
                <a class="link dim f6 f5-l dib mr3 mr4-l white" href="/tags" title="标签">
                    标签
                </a>
            
                <a class="link dim f6 f5-l dib mr3 mr4-l white" href="/categories" title="分类">
                    分类
                </a>
            
                <a class="link dim f6 f5-l dib mr3 mr4-l white" href="/about" title="关于我">
                    关于我
                </a>
            
        </div>
    </nav>

    <!-- Title -->
    <div class="w-100 mw8 center vh-40 dt">
        <div class="dtc v-mid white">
            <h1 class="f1-l f2-m tc tc-m tl-ns">Thread-pool-多线程并发</h1>
            <p class="f4 fw3 pab-100px tc tc-m tl-ns">2018-10-29</p>
        </div>
    </div>

    <!-- Icon -->
    <div class="relative w-100 mw8 center white dn dn-m db-ns">
        <i class="header-icon fa fa-file-text-o"></i>
    </div>
</div>

<!-- Content -->
<div class="w-100 ph2 ph4-m ph5-l mv5 mv6-l">
    <div class="content">
        <div class="mw8 center">
            <div class="cf">
                <div class="fl w-100 w-70-l mw7 left fw3 lh-copy pr4-ns pr0-m post-content">
                    <!-- Tags Vertical -->
                    
                        <div class="tags-container-vertical">
                            <div class="tags-sub-container">
                                <a class="fw3 ph1 dib" href="/tags/并发/">#并发</a> <a class="fw3 ph1 dib" href="/tags/pool/">#pool</a> <a class="fw3 ph1 dib" href="/tags/synchronized/">#synchronized</a>
                            </div>
                        </div>
                    

                    <!-- Main Post Content -->
                    <h3 id="多线程简介"><a href="#多线程简介" class="headerlink" title="多线程简介"></a>多线程简介</h3><blockquote>
<p>多线程适合多种开发语言的开发, 这是一种思想，基于的是操作系统底层的CPU调度.<br>  此篇介绍线程、多线程、和线程池的使用和机制。<br><a id="more"></a></p>
</blockquote>
<h3 id="进程-线程"><a href="#进程-线程" class="headerlink" title="进程\线程"></a>进程\线程</h3><ol>
<li>进程<blockquote>
<p>1 进程 是指在系统中正在运行的一个应用程序, 每一个进程都有一个PID， 当进程占用太多资源或者卡死的时候，CPU会强杀掉进程。<br>2 每个进程之间是独立的，每个进程均运行在其专用的且受保护的内存空间内。</p>
</blockquote>
</li>
<li>线程<blockquote>
<p>1 个进程由多个线程组成(1个进程至少要有1个线程)。<br>2 线程是进程的基本执行单元，一个进程的所有任务都在线程中执行。</p>
</blockquote>
</li>
</ol>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><ol>
<li>多线程<blockquote>
<p>1个进程中可以开启多个线程，多个线程可以同时执行不同的任务, 多线程一般情况下可以提高程序的执行效率。</p>
</blockquote>
</li>
<li>多线程原理<blockquote>
<p>对于单核CPU来说，同一时间，CPU只能处理1个线程，只有1个线程正在执行，现在大部分CPU都是4核8线程。<br>   多线程同时执行的本质：是CPU快速的在多个线程之间的切换，这个时间非常的短在毫秒级别，以至于用户无法察觉。<br>   CPU调度线程的时间足够快，就造成了多线程的“同时”执行。<br>   如果线程数非常多，CPU会在n个线程之间切换，消耗大量的CPU资源，每个线程被调度的次数会降低，线程的执行效率降低。</p>
</blockquote>
</li>
<li>多线程的优点<blockquote>
<p>能适当提高程序的执行效率，但是在业务简单时，单线程会比多线程更快。<br>  能适当提高资源的利用率(CPU、内存)。<br>  线程上的任务执行完成后，线程会自动销毁。</p>
</blockquote>
</li>
<li>多线程的缺点<blockquote>
<p>开启线程需要占用一定的内存空间(默认情况下，每一个线程都占用512KB)，如果开启大量的线程，会占用大量的内存空间，降低程序的性能。<br>  线程越多，CPU在调用线程上的开销就越大。<br>  程序设计更加复杂，比如线程间的通信、多线程的数据共享。</p>
</blockquote>
</li>
<li>主线程<blockquote>
<p>一个程序运行后，默认会开启1个线程，称为“主线程”或“UI线程”，java中的main方法就是一个程序的主线程，如果这个方法体中的业务逻辑存在while循环、线程池<br> 、websorcket等阻塞程序的，那么会使main方法阻塞，程序则不会退出，这也是程序正常运行不退出的原因；一些简单类的main方法会退出是因为并没有阻塞main方法。<br> 主线程一般用来刷新UI界面，处理UI事件。<br> 主线程使用注意：别将耗时的操作放到主线程中，因为耗时操作会卡住主线程，严重影响UI的流畅度，给用户一种卡的坏体验。</p>
</blockquote>
</li>
</ol>
<h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><ol>
<li>同步执行<blockquote>
<p>写程序的时候都是从上到下，从左到右，代码执行顺序也是从上到下从右到左。<br> 1个线程执行多个任务，也是依次执行a-&gt;b-&gt;c。<br> 1个线程同一时间执行1个任务。</p>
</blockquote>
</li>
<li>异步执行<blockquote>
<p>多个线程可以同时执行多个任务。<br>  多个线程执行多个任务可以同时执行a，b，c。</p>
</blockquote>
</li>
<li>synchronized<blockquote>
<p>同步块大家都比较熟悉，通过 synchronized 关键字来实现；所有加上 synchronized 的方法和块语句，在多线程访问的时候，同一时刻只能有一个线程能够访问。</p>
</blockquote>
</li>
<li>wait()、notify()、notifyAll()<blockquote>
<p>这三个方法是 java.lang.Object 的 final native 方法，任何继承 java.lang.Object 的类都有这三个方法。<br>  它们是Java语言提供的实现线程间阻塞和控制进程内调度的底层机制，平时我们会很少用到的。</p>
</blockquote>
</li>
<li>wait()：<blockquote>
<p>导致线程进入等待状态，直到它被其他线程通过notify()或者notifyAll唤醒，该方法只能在同步方法中调用。</p>
</blockquote>
</li>
<li>notify()：<blockquote>
<p>随机选择一个在该对象上调用wait方法的线程，解除其阻塞状态，该方法只能在同步方法或同步块内部调用。</p>
</blockquote>
</li>
<li>notifyAll()：<blockquote>
<p>解除所有那些在该对象上调用wait方法的线程的阻塞状态，同样该方法只能在同步方法或同步块内部调用。<br>  调用这三个方法中任意一个，当前线程必须是锁的持有者，如果不是会抛出一个 IllegalMonitorStateException 异常。</p>
</blockquote>
</li>
<li>wait()与Thread.sleep(long time)的区别<blockquote>
<p>sleep()   ：方法在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），该线程不丢失任何监视器的所属权，sleep() 是 Thread 类专属的静态方法，针对一个特定的线程。<br>  wait()    : 方法使实体所处线程暂停执行，从而使对象进入等待状态，直到被 notify() 方法通知或者 wait() 的等待的时间到。<br>  sleep()   : 方法使持有的线程暂停运行，从而使线程进入休眠状态，直到用interrupt 方法来打断他的休眠或者 sleep 的休眠的时间到。<br>  wait()    : 方法进入等待状态时会释放同步锁，而 sleep() 方法不会释放同步锁。所以，当一个线程无限 sleep 时又没有任何人去 interrupt 它的时候，程序就产生大麻烦了。<br>  notify()  : 是用来通知线程，但在 notify() 之前线程是需要获得 lock 的。另个意思就是必须写在 synchronized(lockobj) {…} 之中。<br>  wait()    : 也是这个样子，一个线程需要释放某个 lock，也是在其获得 lock 情况下才能够释放，所以 wait() 也需要放在 synchronized(lockobj) {…} 之中。</p>
</blockquote>
</li>
<li>volatile 关键字<blockquote>
<p>volatile 是一个特殊的修饰符，只有成员变量才能使用它。在Java并发程序缺少同步类的情况下，多线程对成员变量的操作对其它线程是透明的。<br>  volatile 变量可以保证下一个读取操作会在前一个写操作之后发生。线程都会直接从内存中读取该变量并且不缓存它。这就确保了线程读取到的变量是同内存中是一致的。</p>
</blockquote>
</li>
<li>ThreadLocal 变量<blockquote>
<p>ThreadLocal 是Java里一种特殊的变量。每个线程都有一个 ThreadLocal 就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。<br>  如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。首先，通过复用减少了代价高昂的对象的创建个数。<br>  其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。</p>
</blockquote>
</li>
<li><p>Join() 方法</p>
<blockquote>
<p>join() 方法定义在 Thread 类中，所以调用者必须是一个线程，join() 方法主要是让调用该方法的 Thread 完成 run() 方法里面的东西后，再执行 join() 方法后面的代码。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Thread</span> t1 = <span class="literal">new</span> <span class="keyword">Thread</span>(计数线程一);  </span><br><span class="line"><span class="keyword">Thread</span> t2 = <span class="literal">new</span> <span class="keyword">Thread</span>(计数线程二);  </span><br><span class="line">t1.start(); </span><br><span class="line">t1.<span class="keyword">join</span>(); <span class="comment">// 等待计数线程一执行完成，再执行计数线程二</span></span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>启动 t1 后，调用了 join() 方法，直到 t1 的计数任务结束，才轮到 t2 启动，然后 t2 才开始计数任务，两个线程是按着严格的顺序来执行的。<br>  如果 t2 的执行需要依赖于 t1 中的完整数据的时候，这种方法就可以很好的确保两个线程的同步性。</p>
</blockquote>
</li>
<li>Thread.yield() 方法<blockquote>
<p>Thread.sleep(long time)：线程暂时终止执行（睡眠）一定的时间。<br>  Thread.yield()：线程放弃运行，将CPU的控制权让出。<br>  这两个方法都会将当前运行线程的CPU控制权让出来，但 sleep() 方法在指定的睡眠时间内一定不会再得到运行机会，直到它的睡眠时间完成；<br>  而 yield() 方法让出控制权后，还有可能马上被系统的调度机制选中来运行，比如，执行yield()方法的线程优先级高于其他的线程，那么这个线程即使执行了 yield() 方法也可能不能起到让出CPU<br>  控制权的效果，因为它让出控制权后，进入排队队列，调度机制将&gt;从等待运行的线程队列中选出一个等级最高的线程来运行，那么它又（很可能）被选中来运行。</p>
</blockquote>
</li>
</ol>
<h3 id="Java-多线程的实现的三种方式"><a href="#Java-多线程的实现的三种方式" class="headerlink" title="Java 多线程的实现的三种方式"></a>Java 多线程的实现的三种方式</h3><ol>
<li>继承thread方式<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">newThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void start() &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>Thread 类中的 start() 和 run() 方法有什么区别<br>  调用 start() 方法才会启动新线程；如果直接调用 Thread 的 run() 方法，它的行为就会和普通的方法一样；为了在新的线程中执行我们的代码，必须使用 Thread.start() 方法。</p>
<ol start="2">
<li>实现runable接口方式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<ol start="3">
<li>继承thread其实也是实现runable接口的方式实现的<br><img src="/images/thread.png" alt=""></li>
<li><p>实现callable接口</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> NewCallableThread <span class="keyword">implements</span> Callable&lt;String&gt; &#123;<span class="comment">//String 是线程的返回值类型</span></span><br><span class="line">    <span class="keyword">private</span> String threadName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> NewCallableThread(String threadName, <span class="keyword">int</span> <span class="keyword">count</span>, Object obj) &#123;</span><br><span class="line">        <span class="keyword">this</span>.threadName = threadName;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">count</span> = <span class="keyword">count</span>;</span><br><span class="line">        <span class="keyword">this</span>.obj   = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> String <span class="keyword">call</span>()&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">count</span> &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">count</span> ++;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.<span class="keyword">println</span>(threadName + <span class="string">"&gt;count&gt;"</span> + <span class="keyword">count</span> +<span class="string">"object is "</span> + obj);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"这是返回值"</span>;<span class="comment">//callable接口可以返回线程的执行结果,也可以抛出异常，例如此线程处理完的数据结果可返回给调用者，但是线程不会释放资源直到拿到返回值，所以如果不需要返回return null即可</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        NewCallableThread thread1 = <span class="keyword">new</span> NewCallableThread(<span class="string">"thread1"</span>, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">        thread1.<span class="keyword">call</span>();</span><br><span class="line">        NewCallableThread thread2 = <span class="keyword">new</span> NewCallableThread(<span class="string">"thread2"</span>, <span class="number">5</span>, <span class="string">"hello"</span>);</span><br><span class="line">        thread2.<span class="keyword">call</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>单线程和多线程演示</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String threadName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Object obj;<span class="comment">//obj 是任何类型的可将此对象传入线程中使用</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> NewThread(String threadName, <span class="keyword">int</span> <span class="keyword">count</span>, Object obj) &#123;</span><br><span class="line">        <span class="keyword">this</span>.threadName = threadName;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">count</span> = <span class="keyword">count</span>;</span><br><span class="line">        <span class="keyword">this</span>.obj   = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> run()&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">count</span> &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">count</span> ++;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(threadName + <span class="string">"&gt;count&gt;"</span> + <span class="keyword">count</span> +<span class="string">"object is "</span> + obj);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        NewThread thread1 = <span class="keyword">new</span> NewThread(<span class="string">"thread1"</span>, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">        thread1.run();</span><br><span class="line">        NewThread thread2 = <span class="keyword">new</span> NewThread(<span class="string">"thread2"</span>, <span class="number">5</span>, <span class="string">"hello"</span>);</span><br><span class="line">        thread2.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>thread1、thread2都是单独的一个线程,都是由CPU调度执行</p>
<ol start="6">
<li>附runable和callable的接口源码<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>Runnable &#123;</span><br><span class="line">    public void <span class="builtin-name">run</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public<span class="built_in"> interface </span>Callable&lt;V&gt; &#123;</span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<ol start="7">
<li>runable和callable的对比<blockquote>
<p>Callable 接口下的方法是 call()，Runnable 接口的方法是 run()。<br>   Callable 的任务执行后可返回值，而 Runnable 的任务是不能返回值的。<br>   call() 方法可以抛出异常，run()方法不可以的。<br>   运行 Callable 任务可以拿到一个 Future 对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。<br>   通过 Future 对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。</p>
</blockquote>
</li>
<li><p>附future接口的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>boolean cancel(boolean mayInterruptIfRunning);<br>   此方法试图取消对此任务的执行。<strong>[任务已完成、已取消，或者由于某些其他原因而无法取消，则此尝试将失败，cancel调用成功后，isCancelled和isDone将始终返回true]</strong>，<br>   mayInterruptIfRunning 参数确定是否应该使用试图停止任务的方式来中断执行此任务的线程</p>
</blockquote>
<blockquote>
<p>boolean isCancelled(); 如果在任务正常完成前将其取消，则返回 true</p>
</blockquote>
<blockquote>
<p>boolean isDone(); 任务是否已完成</p>
</blockquote>
<blockquote>
<p>V get() throws InterruptedException, ExecutionException; 如有必要等待线程执行完毕，获取返回结果</p>
</blockquote>
<blockquote>
<p>V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; 在规定时间内等待线程执行完毕，获取返回结果</p>
</blockquote>
</li>
<li><p>FutureTask-Thread的设计优化</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; &#123;</span><br><span class="line">    <span class="built_in">..</span>.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public<span class="built_in"> interface </span>RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123;</span><br><span class="line">    void <span class="builtin-name">run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>FutureTask 实现了 Runnable 和 Future，所以兼顾两者优点，既可以在 Thread 中使用，又可以在 ExecutorService 中使用。</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;<span class="keyword">String</span>&gt; callable = <span class="keyword">new</span> <span class="type">Callable</span>&lt;<span class="keyword">String</span>&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> call() throws Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"something"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">FutureTask&lt;<span class="keyword">String</span>&gt; task = <span class="keyword">new</span> <span class="type">FutureTask</span>&lt;<span class="keyword">String</span>&gt;(callable);</span><br><span class="line"></span><br><span class="line">Thread t = <span class="keyword">new</span> <span class="type">Thread</span>(task);</span><br><span class="line">t.start(); <span class="comment">// 启动线程</span></span><br><span class="line">task.cancel(<span class="literal">true</span>); <span class="comment">// 取消线程</span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>使用 FutureTask 的好处是 FutureTask 弥补了Thread 的不足，它可以让调用者准确地知道线程什么时候执行完成并获得线程执行完成后的返回结果。<br>   FutureTask 是一种可以取消的异步的计算任务，它的计算是通过 Callable 实现的，它等价于可以携带结果的 Runnable，并且有三个状态：等待、运行和完成。<br>   完成包括所有计算以任意的方式结束，包括正常结束、取消和异常。</p>
</blockquote>
</li>
</ol>
<hr>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ol>
<li>线程池简介<blockquote>
<p>Java里面线程池的顶级接口是 Executor，不过真正的线程池接口是 ExecutorService， ExecutorService 的默认实现是 ThreadPoolExecutor；<br>普通类 Executors 里面调用的就是 ThreadPoolExecutor。</p>
</blockquote>
</li>
<li>线程池的优点<blockquote>
<p>1 避免线程的创建和销毁带来的性能开销。<br>   2 避免大量的线程间因互相抢占系统资源导致的阻塞现象。<br>   3 能够对线程进行简单的管理并提供定时执行、间隔执行等功能。</p>
</blockquote>
</li>
<li><p>如何初始化一个线程池, 并调用需要用到的线程处理数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewPool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> corePoolSize = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> maximumPoolSize = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> BlockingQueue&lt;Runnable&gt; workQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService pool = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initPool</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        pool = <span class="keyword">new</span> ThreadPoolExecutor(corePoolSize, maximumPoolSize, <span class="number">0L</span>, TimeUnit.MILLISECONDS, workQueue);</span><br><span class="line">        <span class="comment">//或者使用Executors创建线程池</span></span><br><span class="line">        <span class="comment">//pool = Executors.newSingleThreadExecutor();</span></span><br><span class="line">        <span class="comment">//pool = Executors.newCachedThreadPool();</span></span><br><span class="line">        <span class="comment">//pool = Executors.newFixedThreadPool(5);</span></span><br><span class="line">        <span class="comment">//pool = Executors.newScheduledThreadPool(5);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当有新的数据时调用poolAddThread(String,int,Object obj)处理传入的数据，例如如obj, object就相当于数据</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">poolAddThread</span><span class="params">(String threadName, <span class="keyword">int</span> count, Object obj)</span> </span>&#123;</span><br><span class="line">        NewThread thread = <span class="keyword">new</span> NewThread(threadName, count, obj);</span><br><span class="line">        pool.submit(thread);</span><br><span class="line">        NewCallableThread callThread = <span class="keyword">new</span> NewCallableThread(threadName, count, obj);</span><br><span class="line">        pool.submit(callThread);</span><br><span class="line">        pool.execute(thread);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        initPool();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>execute 和submit的区别在于submit可以抛出异常和返回结果，给外部调用者处理，例如某一个task失败则终止其他task执行，或者shutdown线程池.</p>
</blockquote>
</li>
<li><p>线程池分类及比较<br>Executors 提供四种线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Executors</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60L</span>, TimeUnit.SECONDS, </span><br><span class="line">                            <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>1 newCachedThreadPool<br>    是一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。<br>    调用 execute() 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。<br>    因此，长时间保持空闲的线程池不会使用任&gt;何资源。注意，可以使用 ThreadPoolExecutor 构造方法创建具有类似属性但细节不同（例如超时参数）的线程池。</p>
</blockquote>
<blockquote>
<p>2 newSingleThreadExecutor<br>    创建是一个单线程池，也就是该线程池只有一个线程在工作，所有的任务是串行执行的，如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它，<br>    此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p>
</blockquote>
<blockquote>
<p>3 newFixedThreadPool<br>    创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小，线程池的大小一旦达到最大值就会保持不变，<br>    如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</p>
</blockquote>
<blockquote>
<p>4 newScheduledThreadPool<br>    创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。</p>
</blockquote>
<ol start="5">
<li>ThreadPoolExecutor构造函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                        TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                        BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                        ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, </span><br><span class="line">        threadFactory, defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>1 corePoolSize：线程池的核心线程数，一般情况下不管有没有任务都会一直在线程池中一直存活，只有在 ThreadPoolExecutor 中的方法 allowCoreThreadTimeOut(boolean value) 设置为 true 时，闲置的核心线程会存   在超时机制，如果在指定时间没有新任务来时，核心线程也会被终止，而这个时间间隔由第3个属性 keepAliveTime 指定。</p>
</blockquote>
<blockquote>
<p>2 maximumPoolSize：线程池所能容纳的最大线程数，当活动的线程数达到这个值后，后续的新任务将会被阻塞。</p>
</blockquote>
<blockquote>
<p>3 keepAliveTime：控制线程闲置时的超时时长，超过则终止该线程。一般情况下用于非核心线程，只有在 ThreadPoolExecutor 中的方法 allowCoreThreadTimeOut(boolean value) 设置为 true时，也作用于核心线程。</p>
</blockquote>
<blockquote>
<p>4 unit：用于指定 keepAliveTime 参数的时间单位，TimeUnit 是个 enum 枚举类型，常用的有：TimeUnit.HOURS(小时)、TimeUnit.MINUTES(分钟)、TimeUnit.SECONDS(秒) 和 TimeUnit.MILLISECONDS(毫秒)等。</p>
</blockquote>
<blockquote>
<p>5 workQueue：线程池的任务队列，通过线程池的 execute(Runnable command) 方法会将任务 Runnable 存储在队列中，之后我会出一个submit和excute的详细对比。</p>
</blockquote>
<blockquote>
<p>6 threadFactory：线程工厂，它是一个接口，用来为线程池创建新线程的。</p>
</blockquote>
<ol start="6">
<li>线程池的关闭</li>
</ol>
<blockquote>
<p>ThreadPoolExecutor 提供了两个方法，用于线程池的关闭，分别是 shutdown() 和 shutdownNow()。<br>  shutdown()：不会立即的终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务。<br>  shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务。</p>
</blockquote>
<hr>
<p><a href="https://www.jianshu.com/p/b8197dd2934c" target="_blank" rel="noopener">参考https://www.jianshu.com/p/b8197dd2934c</a></p>

                    
                    <!-- Tags Bottom -->
                    
                        <div class="tags-container-bottom">
                            <i class="fa fa-tag pr3 text-main-color"></i><a class="fw3 ph1 dib" href="/tags/并发/">#并发</a> <a class="fw3 ph1 dib" href="/tags/pool/">#pool</a> <a class="fw3 ph1 dib" href="/tags/synchronized/">#synchronized</a>
                        </div>
                    

                    <!-- Comments -->
                    



                </div>
                <div class="fl w-100 w-30-l center fw3 lh-copy pl4-ns tl black-50">
                    
                    <hr class="dn-l mw4 black-50 mt5">
                    
                    <!-- Widget 1: About -->
                    <!-- <div class="mt5 mt0-l">
    <article class="dt db-l mw8 mw8-m mw5-ns center ml0-l bg-white mv3">
        <div class="dn dtc-m db-l v-mid tc pr4 pr0-l" style="min-width: 6rem;">
            <img src="" class="mb4-l br-100 h3 w3 h4-l w4-l dib" title="Jack Romer">
        </div>
        <div class="dtc db-l v-mid lh-copy measure center f6 black-50 tj">
            
        </div>
    </article>
</div> -->

                    <hr class="dn-l mw4 black-50 mt5">
                    
                    <!-- Widget 2: Categories -->
                    
                        <div class="mt5 tc tl-l">
    <h3>分类</h3>
    
        <p>
            <a href="/categories/Java/">Java</a>
        </p>
    
        <p>
            <a href="/categories/Java/Thread/">Thread</a>
        </p>
    
</div>


                        <hr class="dn-l mw4 black-50 mt5">
                    

                    <!-- Widget 3: Recent Posts -->
                    <div class="mt5 tc tl-l">
    <h3>近期文章</h3>
    
        <p>
            <a href="/2018/10/31/storm安装教程/">storm安装教程</a>
        </p>
    
        <p>
            <a href="/2018/10/29/Netty-NIO-介绍和使用/">Netty-Nio</a>
        </p>
    
        <p>
            <a href="/2018/10/29/Spring-transactional-事务/">Spring-transactional-事务</a>
        </p>
    
        <p>
            <a href="/2018/10/29/Thread-pool-多线程并发/">Thread-pool-多线程并发</a>
        </p>
    
</div>
                </div>
            </div>
        </div>
    </div>
</div>


<!-- Footer -->
<div class="bg-1 ph2 ph5-ns pv5">
        <div class="mv8">
            <div class="center tc">
                
                    <div class="dib mh3">
                        <a class="f3 f2-ns white dim" href="https://twitter.com/?lang=en" target="_blank">
                            <i class="fa fa-twitter"></i>
                        </a>
                    </div>
                
                    <div class="dib mh3">
                        <a class="f3 f2-ns white dim" href="https://www.facebook.com/" target="_blank">
                            <i class="fa fa-facebook"></i>
                        </a>
                    </div>
                
                    <div class="dib mh3">
                        <a class="f3 f2-ns white dim" href="https://dribbble.com/" target="_blank">
                            <i class="fa fa-dribbble"></i>
                        </a>
                    </div>
                
                    <div class="dib mh3">
                        <a class="f3 f2-ns white dim" href="https://github.com/klugjo/hexo-theme-anodyne" target="_blank">
                            <i class="fa fa-github"></i>
                        </a>
                    </div>
                
                    <div class="dib mh3">
                        <a class="f3 f2-ns white dim" href="https://plus.google.com/" target="_blank">
                            <i class="fa fa-google-plus"></i>
                        </a>
                    </div>
                
                    <div class="dib mh3">
                        <a class="f3 f2-ns white dim" href="https://www.behance.net/" target="_blank">
                            <i class="fa fa-behance"></i>
                        </a>
                    </div>
                
                    <div class="dib mh3">
                        <a class="f3 f2-ns white dim" href="https://500px.com/" target="_blank">
                            <i class="fa fa-500px"></i>
                        </a>
                    </div>
                
                    <div class="dib mh3">
                        <a class="f3 f2-ns white dim" href="mailto:test@example.com" target="_blank">
                            <i class="fa fa-envelope"></i>
                        </a>
                    </div>
                
                    <div class="dib mh3">
                        <a class="f3 f2-ns white dim" href="/#" target="_blank">
                            <i class="fa fa-rss"></i>
                        </a>
                    </div>
                
            </div>
            <div class="f6 f5-ns center tc white pt5 fw3">
                @Untitled. All right reserved | Design & Hexo <a class="link dim white" href="http://www.codeblocq.com/">Jonathan Klughertz</a>
            </div>
        </div>
    </div>

<!-- After Footer -->
<!-- Disqus Comments -->



</body>

</html>