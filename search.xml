<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Kafka介绍以及集群安装</title>
      <link href="/2019/01/21/kafka%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/"/>
      <url>/2019/01/21/kafka%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文介绍KAFKA的特性和集群安装以及配合ACTIVEMQ使用<br><a id="more"></a></p><h2 id="什么是KAFKA"><a href="#什么是KAFKA" class="headerlink" title="什么是KAFKA"></a>什么是KAFKA</h2><blockquote><p>Kafka是由Apache软件基金会开发的一个开源流处理平台，由Scala和Java编写。Kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者规模的网站中的所有动作流数据。 这种动作（网页浏览，搜索和其他用户的行动）是在现代网络上的许多社会功能的一个关键因素。 这些数据通常是由于吞吐量的要求而通过处理日志和日志聚合来解决。 对于像Hadoop一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka的目的是通过Hadoop的并行加载机制来统一线上和离线的消息处理，也是为了通过集群来提供实时的消息。</p></blockquote><h2 id="为什么使用KAFKA"><a href="#为什么使用KAFKA" class="headerlink" title="为什么使用KAFKA"></a>为什么使用KAFKA</h2><blockquote><p>当数据是由上游模块产生，上游模块，使用上游模块的数据计算、统计、分析，这个时候就可以使用消息系统，尤其是分布式消息系统！kafka主要用来存储和接收上游或者下游的数据，也可以自己处理数据.下图是KAFKA和其他分布式消息系统的对比.<br><img src="/images/kafka-01.png" alt=""></p></blockquote><h2 id="KAFKA-协议AMOP"><a href="#KAFKA-协议AMOP" class="headerlink" title="KAFKA 协议AMOP"></a>KAFKA 协议AMOP</h2><blockquote><p>Advanced Message Queuing Protocol （高级消息队列协议）<br>The Advanced Message Queuing Protocol (AMQP)：是一个标准开放的应用层的消息中间件（Message Oriented Middleware）协议。AMQP定义了通过网络发送的字节流的数据格式。<br>因此兼容性非常好，任何实现AMQP协议的程序都可以和与AMQP协议兼容的其他程序交互，可以很容易做到跨语言，跨平台。</p></blockquote><h2 id="KAFKA特性"><a href="#KAFKA特性" class="headerlink" title="KAFKA特性"></a>KAFKA特性</h2><blockquote><p>通过O(1)的磁盘数据结构提供消息的持久化，这种结构对于即使数以TB的消息存储也能够保持长时间的稳定性能。<br>高吞吐量 ：即使是非常普通的硬件Kafka也可以支持每秒数百万的消息。<br>支持通过Kafka服务器和消费机集群来分区消息。<br>支持Hadoop并行数据加载。<br>KAFAK数据备份保证了再其他机器down机的时候，集群的稳定性，同时消息会replication备份，保证数据不丢失，且保证了消息的唯一性。<br>但是KAFKA尚未确保消息的发送与接收绝对可靠(比如,消息重发,消息发送丢失等)，消息消费失败时需要consumer手动重置offset来重新消费该条消息。</p></blockquote><h2 id="KAFKA如何能支持消息数据的高并发"><a href="#KAFKA如何能支持消息数据的高并发" class="headerlink" title="KAFKA如何能支持消息数据的高并发"></a>KAFKA如何能支持消息数据的高并发</h2><h3 id="1、持久性"><a href="#1、持久性" class="headerlink" title="1、持久性"></a>1、持久性</h3><blockquote><p>kafka使用文件存储消息,这就直接决定kafka在性能上严重依赖文件系统的本身特性.且无论任何OS下,对文件系统本身的优化几乎没有可能.文件缓存/直接内存映射等是常用的手段.因为kafka是对日志文件进行append操作,因此磁盘检索的开支是较小的;同时为了减少磁盘写入的次数,broker会将消息暂时buffer起来,当消息的个数(或尺寸)达到一定阀值时,再flush到磁盘,这样减少了磁盘IO调用的次数.</p></blockquote><h3 id="2、性能"><a href="#2、性能" class="headerlink" title="2、性能"></a>2、性能</h3><blockquote><p>需要考虑的影响性能点很多,除磁盘IO之外,我们还需要考虑网络IO,这直接关系到kafka的吞吐量问题.kafka并没有提供太多高超的技巧;对于producer端,可以将消息buffer起来,当消息的条数达到一定阀值时,批量发送给broker;对于consumer端也是一样,批量fetch多条消息.不过消息量的大小可以通过配置文件来指定.对于kafka broker端,似乎有个sendfile系统调用可以潜在的提升网络IO的性能:将文件的数据映射到系统内存中,socket直接读取相应的内存区域即可,而无需进程再次copy和交换. 其实对于producer/consumer/broker三者而言,CPU的开支应该都不大,因此启用消息压缩机制是一个良好的策略;压缩需要消耗少量的CPU资源,不过对于kafka而言,网络IO更应该需要考虑.可以将任何在网络上传输的消息都经过压缩.kafka支持gzip/snappy等多种压缩方式.</p></blockquote><h3 id="3、生产者"><a href="#3、生产者" class="headerlink" title="3、生产者"></a>3、生产者</h3><blockquote><p>负载均衡: producer将会和Topic下所有partition leader保持socket连接;消息由producer直接通过socket发送到broker,中间不会经过任何”路由层”.事实上,消息被路由到哪个partition上,有producer客户端决定.比如可以采用”random””key-hash””轮询”等,如果一个topic中有多个partitions,那么在producer端实现”消息均衡分发”是必要的.<br>  其中partition leader的位置(host:port)注册在zookeeper中,producer作为zookeeper client,已经注册了watch用来监听partition leader的变更事件.<br>  异步发送：将多条消息暂且在客户端buffer起来，并将他们批量的发送到broker，小数据IO太多，会拖慢整体的网络延迟，批量延迟发送事实上提升了网络效率。不过这也有一定的隐患，比如说当producer失效时，那些尚未发送的消息将会丢失。</p></blockquote><h3 id="4、消费者"><a href="#4、消费者" class="headerlink" title="4、消费者"></a>4、消费者</h3><blockquote><p>consumer端向broker发送”fetch”请求,并告知其获取消息的offset;此后consumer将会获得一定条数的消息;consumer端也可以重置offset来重新消费消息.</p></blockquote><h2 id="KAFKA-术语分析"><a href="#KAFKA-术语分析" class="headerlink" title="KAFKA 术语分析"></a>KAFKA 术语分析</h2><blockquote><p>Broker：Kafka集群包含一个或多个服务器，这种服务器被称为broker<br>Topic：每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（<br>物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）<br>Partition:Partition是物理上的概念，每个Topic包含一个或多个Partition,数据也是按partition来存储的，简称为分区.<br>Producer:负责发布消息到Kafka broker<br>Consumer:消息消费者，向Kafka broker读取消息的客户端。<br>Consumer Group：每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group）。</p></blockquote><h2 id="KAFKA架构"><a href="#KAFKA架构" class="headerlink" title="KAFKA架构"></a>KAFKA架构</h2><p><img src="/images/kafka-02.png" alt=""></p><blockquote><p>kafka集群中的消息，是通过Topic（主题）来进行组织的，一个Topic可以认为是一类消息，每个topic将被分成多个partition(区),每个partition在存储层面是append log文件。任何发布到此partition的消息都会被直接追加到log文件的尾部，每条消息在文件中的位置称为offset（偏移量），offset为一个long型数字，它是唯一标记一条消息。它唯一的标记一条消息。kafka并没有提供其他额外的索引机制来存储offset，因为在kafka中几乎不允许对消息进行“随机读写”，其结构如下图：<br><img src="/images/kafka-03.png" alt=""></p></blockquote><h2 id="搭建KAFKA集群"><a href="#搭建KAFKA集群" class="headerlink" title="搭建KAFKA集群"></a>搭建KAFKA集群</h2><h3 id="1-下载KAFKA并解压-假设zookeeper集群已经搭建好了"><a href="#1-下载KAFKA并解压-假设zookeeper集群已经搭建好了" class="headerlink" title="1. 下载KAFKA并解压(假设zookeeper集群已经搭建好了)"></a>1. 下载KAFKA并解压(假设zookeeper集群已经搭建好了)</h3><p><a href="http://kafka.apache.org/downloads.html" target="_blank" rel="noopener">下载KAFKAhttp://kafka.apache.org/downloads.html</a></p><h3 id="2-修改配置文件kafka-config-server-properties"><a href="#2-修改配置文件kafka-config-server-properties" class="headerlink" title="2. 修改配置文件kafka/config/server.properties"></a>2. 修改配置文件kafka/config/server.properties</h3><pre class=" language-linux"><code class="language-linux">##node1下broker.id=3advertised.listeners=PLAINTEXT:////your.host.name:9092log.dirs=/home/hadoop/kafka_logzookeeper.connect=192.168.80.123:2181,192.168.80.124:2181,192.168.80.125:2181#node2下broker.id=2advertised.listeners=PLAINTEXT:////your.host.name:9092log.dirs=/home/hadoop/kafka_logzookeeper.connect=192.168.80.123:2181,192.168.80.124:2181,192.168.80.125:2181#node3下broker.id=3advertised.listeners=PLAINTEXT:////your.host.name:9092log.dirs=/home/hadoop/kafka_logzookeeper.connect=192.168.80.123:2181,192.168.80.124:2181,192.168.80.125:2181</code></pre><h3 id="3-启动zookeeper和kafka集群"><a href="#3-启动zookeeper和kafka集群" class="headerlink" title="3.启动zookeeper和kafka集群"></a>3.启动zookeeper和kafka集群</h3><pre class=" language-linux"><code class="language-linux">启动zookeeper    bin/zookeeper-server-start.sh config/zookeeper.properties启动kafka        bin/kafka-server-start.sh config/server.properties(集群下需要三台都启动)###创建主题bin/kafka-topics.sh --create --zookeeper 131.10.10.202:2181,131.10.10.203:2181,131.10.10.204:2181 --replication-factor 3 --partitions 8 --topic ff###查看主题bin/kafka-topics.sh --list --zookeeper 131.10.10.202:2181,131.10.10.203:2181,131.10.10.204:2181###删除主题bin/kafka-topics.sh --delete --zookeeper 131.10.10.202:2181,131.10.10.203:2181,131.10.10.204:2181 --topic test启动生产着      bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test启动消费者      bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic test发送消息（模拟kafka发送消息）：./kafka-console-producer.sh --broker-list 131.10.10.202:9092,131.10.10.203:9092,131.10.10.204:9092 –topic    test接收消息：./kafka-console-consumer.sh -zookeeper 131.10.10.202:2181,131.10.10.203:2181,131.10.10.204:2181  --topic test</code></pre><h2 id="使用postman提交配置和删除查看配置"><a href="#使用postman提交配置和删除查看配置" class="headerlink" title="使用postman提交配置和删除查看配置"></a>使用postman提交配置和删除查看配置</h2><blockquote><p>由于Kafka Connect的目的是作为一个服务运行，提供了一个用于管理connector的REST API。默认情况下，此服务的端口是8083。以下是当前支持的终端入口：</p></blockquote><h3 id="创建topic提交的数据"><a href="#创建topic提交的数据" class="headerlink" title="创建topic提交的数据"></a>创建topic提交的数据</h3><blockquote><p>com.company.connector.sink.ActiveMQSinkConnector是自定义的类，并添加JAR到kafka的libs目录中供使用</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token punctuation">{</span>    <span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"iot-data-kafka-mqtt-source"</span><span class="token punctuation">,</span>    <span class="token string">"config"</span><span class="token operator">:</span><span class="token punctuation">{</span>                <span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"iot-data-kafka-mqtt-source"</span><span class="token punctuation">,</span>                <span class="token string">"connector.class"</span><span class="token operator">:</span><span class="token string">"com.company.connector.source.ActiveMQSourceConnector"</span><span class="token punctuation">,</span>                <span class="token string">"topics"</span><span class="token operator">:</span><span class="token string">"ThingsUpstreamSourceTopic"</span><span class="token punctuation">,</span>                <span class="token string">"tasks.max"</span><span class="token operator">:</span><span class="token string">"10"</span><span class="token punctuation">,</span>                <span class="token string">"activemq.server_uris"</span><span class="token operator">:</span><span class="token string">"failover:(tcp://131.10.10.68:50000)?randomize=false"</span><span class="token punctuation">,</span>                <span class="token string">"activemq.destination"</span><span class="token operator">:</span><span class="token string">"Consumer.Iot-Hub-Kafka-Mqtt.VirtualTopic.conpany.v1.things.*.>"</span><span class="token comment" spellcheck="true">//订阅的MQTT的topic</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//--------------------------------------------------------------------------------------</span><span class="token punctuation">{</span>    <span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"iot-data-kafka-mqtt-sink"</span><span class="token punctuation">,</span>    <span class="token string">"config"</span><span class="token operator">:</span><span class="token punctuation">{</span>                <span class="token string">"name"</span><span class="token operator">:</span><span class="token string">"iot-data-kafka-mqtt-sink"</span><span class="token punctuation">,</span>                <span class="token string">"connector.class"</span><span class="token operator">:</span><span class="token string">"com.company.connector.sink.ActiveMQSinkConnector"</span><span class="token punctuation">,</span>                <span class="token string">"topics"</span><span class="token operator">:</span><span class="token string">"ThingsDownstreamMqttSinkTopic"</span><span class="token punctuation">,</span>                <span class="token string">"tasks.max"</span><span class="token operator">:</span><span class="token string">"10"</span><span class="token punctuation">,</span>                <span class="token string">"activemq.server_uris"</span><span class="token operator">:</span><span class="token string">"failover:(tcp://131.10.10.68:50000)?randomize=false"</span>            <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="常用的rest接口"><a href="#常用的rest接口" class="headerlink" title="常用的rest接口"></a>常用的rest接口</h3><pre class=" language-linux"><code class="language-linux">GET /connectors                  返回活跃的connector列表。POST /connectors                 请求的主体是包含name字段和对象config字段（connector的配置参数）的JSON对象。GET /connectors/{name}           获取指定connector的信息。GET /connectors/{name}/config    获取指定connector的配置参数。PUT /connectors/{name}/config    更新指定connector的配置参数。GET /connectors/{name}/status    获取connector的当前状态，包括它是否正在运行，失败，暂停等。GET /connectors/{name}/tasks     获取当前正在运行的connector的任务列表。GET /connectors/{name}/tasks/{taskid}/status       获取任务的当前状态，包括是否是运行中的，失败的，暂停的等。PUT /connectors/{name}/pause                       暂停连接器和它的任务，停止消息处理，直到connector恢复。PUT /connectors/{name}/resume                      恢复暂停的connector（如果connector没有暂停，则什么都不做）。POST /connectors/{name}/restart                    重启connector（connector已故障）。POST /connectors/{name}/tasks/{taskId}/restart     重启单个任务 (通常这个任务已失败)。DELETE /connectors/{name}                          删除connector, 停止所有的任务并删除其配置。</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>KAFKA作为支持高并发，高可用的分布式消息系统现在广泛的应用在各大商业平台，如果你需要对消息处理做高并发的支持，并且希望消息日志和消息具有高可靠性，可以选用KAFAKA做分布式消息系统，其结合其他分布式消息系统可组成一套高可用、高并发的消息处理流程，例如activeMQ做上游消息处理，kafka集群做中间层持久化数据和消息分发，使用storm做消息的实时处理.</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> MQTT </category>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用Hibernate.jdbc.Work高性能处理批量数据</title>
      <link href="/2019/01/18/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%94%9FJDBC%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/"/>
      <url>/2019/01/18/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%94%9FJDBC%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文介绍如何使用Hibernate.jdbc.Work批量处理大量的数据（QCUD）<br><a id="more"></a></p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>为何使用原生的批量处理数据操作而不用现有的hibernate框架实现呢，因为hibernate对插入和更新的处理方式在大量数据插入式并不能更好的支持。</p></blockquote><blockquote><p>需求分析，如果你希望将一个对象的集合全部插入到数据库，但使用hibernate框架的批处理速度回比较慢，hibernate其实是一条一条的插入数据的，JDBC的BATCH不同是JDBC的bactch会先将sql预编译，再将集合的值SET进去，大大节省了编译SQL的时间。</p></blockquote><blockquote><p>经过测试：使用hibernate插入10条数据，需要预编译SQL10次，而原始JDBC的batch只需要预编译一次，且随着需要插入的数据增长需要的时间区别也越来越大，使用hibernate默认batch插入10000条数据需要1-2秒，优化后只需要200毫秒左右.</p></blockquote><h2 id="hibernate-de-persist-he-merge"><a href="#hibernate-de-persist-he-merge" class="headerlink" title="hibernate de persist he merge"></a>hibernate de persist he merge</h2><pre class=" language-java"><code class="language-java"> <span class="token comment" spellcheck="true">/**     * Make an instance managed and persistent.     * @param entity  entity instance     * @throws EntityExistsException if the entity already exists.     * (If the entity already exists, the &lt;code>EntityExistsException&lt;/code> may     * be thrown when the persist operation is invoked, or the     * &lt;code>EntityExistsException&lt;/code> or another &lt;code>PersistenceException&lt;/code> may be     * thrown at flush or commit time.)     * @throws IllegalArgumentException if the instance is not an     *         entity     * @throws TransactionRequiredException if invoked on a     *         container-managed entity manager of type     *         &lt;code>PersistenceContextType.TRANSACTION&lt;/code> and there is     *         no transaction     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">persist</span><span class="token punctuation">(</span>Object entity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * Merge the state of the given entity into the     * current persistence context.     * @param entity  entity instance     * @return the managed instance that the state was merged to     * @throws IllegalArgumentException if instance is not an     *         entity or is a removed entity     * @throws TransactionRequiredException if invoked on a     *         container-managed entity manager of type     *         &lt;code>PersistenceContextType.TRANSACTION&lt;/code> and there is     *         no transaction     */</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">merge</span><span class="token punctuation">(</span>T entity<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="通过Hibernate的缓存进行批量插入"><a href="#通过Hibernate的缓存进行批量插入" class="headerlink" title="通过Hibernate的缓存进行批量插入"></a>通过Hibernate的缓存进行批量插入</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HibernateTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        SessionFactory sessionFactory <span class="token operator">=</span> hibernateTemplate<span class="token punctuation">.</span><span class="token function">getSessionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Session session <span class="token operator">=</span> sessionFactory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Transaction tx  <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">beginTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//开启事务</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">50</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Usertable user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Usertable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            user<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"100"</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            session<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">%</span><span class="token number">100</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                session<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  session<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        ts<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        HibernateSessionFactory<span class="token punctuation">.</span><span class="token function">closeSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="直接调用JDBC"><a href="#直接调用JDBC" class="headerlink" title="直接调用JDBC"></a>直接调用JDBC</h2><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>rollbackFor <span class="token operator">=</span> Exception<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> RpcServiceResult <span class="token function">createSubThings</span><span class="token punctuation">(</span>ArrayNode insertArray<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SessionFactory sessionFactory <span class="token operator">=</span> hibernateTemplate<span class="token punctuation">.</span><span class="token function">getSessionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Session session <span class="token operator">=</span> sessionFactory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Transaction tx  <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">beginTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//开启事务</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//do something</span>            String sqlStr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"INSERT INTO  table       ( `attribute1`,"</span>                                                                <span class="token operator">+</span> <span class="token string">" `attribute2`, "</span>                                                                <span class="token operator">+</span> <span class="token string">" `attribute3`"</span>                                                                <span class="token operator">+</span> <span class="token string">") "</span>                                    <span class="token operator">+</span>  <span class="token string">"VALUES (?, ?, ?);"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Work work <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Work</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//Contract for performing a discrete piece of org.hibernate.jdbc.Work;</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Connection connection<span class="token punctuation">)</span> <span class="token keyword">throws</span> SQLException <span class="token punctuation">{</span>                    PreparedStatement statement <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sqlStr<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> insertArray<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        JsonNode subThingJsonNode <span class="token operator">=</span> insertArray<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                        String value1     <span class="token operator">=</span> subThingJsonNode<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"key1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">asText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        String value2   <span class="token operator">=</span> subThingJsonNode<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"key2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">asText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        String value3   <span class="token operator">=</span> subThingJsonNode<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"key3"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">asText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        statement<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>value1<span class="token punctuation">)</span><span class="token punctuation">;</span>                        statement<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>value2<span class="token punctuation">)</span><span class="token punctuation">;</span>                        statement<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span>value3<span class="token punctuation">)</span><span class="token punctuation">;</span>                        statement<span class="token punctuation">.</span><span class="token function">addBatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    statement<span class="token punctuation">.</span><span class="token function">executeBatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span>            session<span class="token punctuation">.</span><span class="token function">doWork</span><span class="token punctuation">(</span>work<span class="token punctuation">)</span><span class="token punctuation">;</span>            tx<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//提交事务</span>            ObjectNode responseNode <span class="token operator">=</span> JsonNodeFactory<span class="token punctuation">.</span>instance<span class="token punctuation">.</span><span class="token function">objectNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RpcServiceResult</span><span class="token punctuation">(</span>HttpStatus<span class="token punctuation">.</span>SC_OK<span class="token punctuation">,</span> responseNode<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>HibernateException en<span class="token punctuation">)</span> <span class="token punctuation">{</span>            tx<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"Failed to save the ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RpcServiceResult</span><span class="token punctuation">(</span>HttpStatus<span class="token punctuation">.</span>SC_INTERNAL_SERVER_ERROR<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> en<span class="token punctuation">)</span> <span class="token punctuation">{</span>            logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"Failed to save the ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            tx<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RpcServiceResult</span><span class="token punctuation">(</span>HttpStatus<span class="token punctuation">.</span>SC_INTERNAL_SERVER_ERROR<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            session<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>使用此方法批量提交插入操作，不仅可以提高效率，也可以防止SQL注入, 同时UPDATE, DELETE 等操作也可以使用此方式.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Jdbc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Storm介绍、集群搭建以及topology使用</title>
      <link href="/2018/10/31/storm%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
      <url>/2018/10/31/storm%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍STORM，以及storm集群的安装和使用</p><a id="more"></a><h2 id="什么是storm"><a href="#什么是storm" class="headerlink" title="什么是storm"></a>什么是storm</h2><blockquote><p>Apache Storm是自由开源的分布式实时计算系统，擅长处理海量数据，适用于数据实时处理而非批处理。<br>批处理使用的大多是鼎鼎大名的hadoop或者hive，作为一个批处理系统，hadoop以其吞吐量大、自动容错等优点，在海量数据处理上得到了广泛的使用。但是，hadoop不擅长实时计算，因为它天然就是为批处理而生的，这也是业界一致的共识。否则最近几年也不会有s4,storm,puma这些实时计算系统如雨后春笋般冒出来啦。STORM就是为了处理及时的消费者请求而生，在用户给出需求时及时的处理数据并给出响应的结果。</p></blockquote><h2 id="storm处理流程"><a href="#storm处理流程" class="headerlink" title="storm处理流程"></a>storm处理流程</h2><p><img src="/images/storm.jpg" alt=""></p><blockquote><p>可以看出storm的数据处理是交给ZK处理分发的，由nimbus管理supervisor，supervis管理worker，worker才是真正做数据处理的进程，worker提交TASK，类似多线程提交任务，整个流程达到消息的实时处理能力。</p></blockquote><h2 id="spout和bolt"><a href="#spout和bolt" class="headerlink" title="spout和bolt"></a>spout和bolt</h2><h3 id="spout"><a href="#spout" class="headerlink" title="spout"></a>spout</h3><blockquote><p>spout是数据源，例如spout可以调用 Twitter API 得到一个微博数据流，就是从外部数据源（队列、数据库等）中读取数据，封装成元组，形成STREAM数据流。<br><img src="/images/spout1.png" alt=""></p></blockquote><h3 id="bolt"><a href="#bolt" class="headerlink" title="bolt"></a>bolt</h3><blockquote><p>bolt是用来处理数据的，可以对一些数据流（不只一个数据流）进行处理，可能会产生新的STREAM数据流。对一些复杂的数据流变换，<br>比如从一个微博流中计算一个热门话题流，就需要很多步骤，因此就有多个bolt，因此bolt中就有很多处理，比如运行函数，做流式聚合，流式链接，访问数据库等等。<br><img src="/images/tuple.jpg" alt=""><br>不同的bolt可以订阅相同的spout来达到消息共享的目的，比如来了一条数据，bolt1是做数据入库处理，bolt2只是做简单的日志记录，bolt3….<br><img src="/images/spout-bolt.png" alt=""></p></blockquote><h3 id="topology"><a href="#topology" class="headerlink" title="topology"></a>topology</h3><blockquote><p>如上图所示 topology就是spout 和 bolt组成的网络拓扑图，Topology就是最高层的逻辑抽象，可以直接送到 Storm 集群去执行。一个Topology图就是流式转换，每个节点是 spout 或者 bolt，图中的每条边就是 bolt 订阅了流，当一个 spout或者 bolt 产生一个元组到一个流时，它就发送元组到订阅了流的每个 bolt。</p></blockquote><h2 id="自定义topology并提交topology到storm集群"><a href="#自定义topology并提交topology到storm集群" class="headerlink" title="自定义topology并提交topology到storm集群"></a>自定义topology并提交topology到storm集群</h2><h3 id="1-首先需要实现storm的spout和bolt接口实现对stream流数据的接收和处理"><a href="#1-首先需要实现storm的spout和bolt接口实现对stream流数据的接收和处理" class="headerlink" title="1.首先需要实现storm的spout和bolt接口实现对stream流数据的接收和处理"></a>1.首先需要实现storm的spout和bolt接口实现对stream流数据的接收和处理</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>xpleaf<span class="token punctuation">.</span>bigdata<span class="token punctuation">.</span>storm<span class="token punctuation">.</span>remote<span class="token punctuation">;</span><span class="token keyword">import</span> cn<span class="token punctuation">.</span>xpleaf<span class="token punctuation">.</span>bigdata<span class="token punctuation">.</span>storm<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>StormUtil<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>storm<span class="token punctuation">.</span>Config<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>storm<span class="token punctuation">.</span>LocalCluster<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>storm<span class="token punctuation">.</span>StormSubmitter<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>storm<span class="token punctuation">.</span>generated<span class="token punctuation">.</span>StormTopology<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>storm<span class="token punctuation">.</span>spout<span class="token punctuation">.</span>SpoutOutputCollector<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>storm<span class="token punctuation">.</span>task<span class="token punctuation">.</span>OutputCollector<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>storm<span class="token punctuation">.</span>task<span class="token punctuation">.</span>TopologyContext<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>storm<span class="token punctuation">.</span>topology<span class="token punctuation">.</span>OutputFieldsDeclarer<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>storm<span class="token punctuation">.</span>topology<span class="token punctuation">.</span>TopologyBuilder<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>storm<span class="token punctuation">.</span>topology<span class="token punctuation">.</span>base<span class="token punctuation">.</span>BaseRichBolt<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>storm<span class="token punctuation">.</span>topology<span class="token punctuation">.</span>base<span class="token punctuation">.</span>BaseRichSpout<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>storm<span class="token punctuation">.</span>tuple<span class="token punctuation">.</span>Fields<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>storm<span class="token punctuation">.</span>tuple<span class="token punctuation">.</span>Tuple<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>storm<span class="token punctuation">.</span>tuple<span class="token punctuation">.</span>Values<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Date<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 1°、实现数字累加求和的案例：数据源不断产生递增数字，对产生的数字累加求和。 * &lt;p> * Storm组件：Spout、Bolt、数据是Tuple，使用main中的Topology将spout和bolt进行关联 * MapReduce的组件：Mapper和Reducer、数据是Writable，通过一个main中的job将二者关联 * &lt;p> * 适配器模式（Adapter）：BaseRichSpout，其对继承接口中一些没必要的方法进行了重写，但其重写的代码没有实现任何功能。 * 我们称这为适配器模式 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StormSumTopology</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 数据源     */</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">OrderSpout</span> <span class="token keyword">extends</span> <span class="token class-name">BaseRichSpout</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> Map conf<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 当前组件配置信息</span>        <span class="token keyword">private</span> TopologyContext context<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当前组件上下文对象</span>        <span class="token keyword">private</span> SpoutOutputCollector collector<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 发送tuple的组件</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">open</span><span class="token punctuation">(</span>Map conf<span class="token punctuation">,</span> TopologyContext context<span class="token punctuation">,</span> SpoutOutputCollector collector<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>conf <span class="token operator">=</span> conf<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>context <span class="token operator">=</span> context<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>collector <span class="token operator">=</span> collector<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/**         * 接收数据的核心方法         */</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">nextTuple</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">long</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                num<span class="token operator">++</span><span class="token punctuation">;</span>                StormUtil<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前时间"</span> <span class="token operator">+</span> StormUtil<span class="token punctuation">.</span>df_yyyyMMddHHmmss<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"产生的订单金额："</span> <span class="token operator">+</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>collector<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Values</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/**         * 是对发送出去的数据的描述schema         */</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">declareOutputFields</span><span class="token punctuation">(</span>OutputFieldsDeclarer declarer<span class="token punctuation">)</span> <span class="token punctuation">{</span>            declarer<span class="token punctuation">.</span><span class="token function">declare</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Fields</span><span class="token punctuation">(</span><span class="token string">"order_cost"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 计算和的Bolt节点     */</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SumBolt</span> <span class="token keyword">extends</span> <span class="token class-name">BaseRichBolt</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> Map conf<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 当前组件配置信息</span>        <span class="token keyword">private</span> TopologyContext context<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当前组件上下文对象</span>        <span class="token keyword">private</span> OutputCollector collector<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 发送tuple的组件</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">prepare</span><span class="token punctuation">(</span>Map stormConf<span class="token punctuation">,</span> TopologyContext context<span class="token punctuation">,</span> OutputCollector collector<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>conf <span class="token operator">=</span> conf<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>context <span class="token operator">=</span> context<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>collector <span class="token operator">=</span> collector<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">private</span> Long sumOrderCost <span class="token operator">=</span> 0L<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**         * 处理数据的核心方法         */</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Tuple input<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Long orderCost <span class="token operator">=</span> input<span class="token punctuation">.</span><span class="token function">getLongByField</span><span class="token punctuation">(</span><span class="token string">"order_cost"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            sumOrderCost <span class="token operator">+=</span> orderCost<span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"商城网站到目前"</span> <span class="token operator">+</span> StormUtil<span class="token punctuation">.</span>df_yyyyMMddHHmmss<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"的商品总交易额"</span> <span class="token operator">+</span> sumOrderCost<span class="token punctuation">)</span><span class="token punctuation">;</span>            StormUtil<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/**         * 如果当前bolt为最后一个处理单元，该方法可以不用管         */</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">declareOutputFields</span><span class="token punctuation">(</span>OutputFieldsDeclarer declarer<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 构建拓扑，相当于在MapReduce中构建Job     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        TopologyBuilder builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TopologyBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**         * 设置spout和bolt的dag（有向无环图）         */</span>        builder<span class="token punctuation">.</span><span class="token function">setSpout</span><span class="token punctuation">(</span><span class="token string">"id_order_spout"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">OrderSpout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        builder<span class="token punctuation">.</span><span class="token function">setBolt</span><span class="token punctuation">(</span><span class="token string">"id_sum_bolt"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">SumBolt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">shuffleGrouping</span><span class="token punctuation">(</span><span class="token string">"id_order_spout"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 通过不同的数据流转方式，来指定数据的上游组件</span>        <span class="token comment" spellcheck="true">// 使用builder构建topology</span>        StormTopology topology <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">createTopology</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String topologyName <span class="token operator">=</span> StormSumTopology<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 拓扑的名称</span>        Config config <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// Config()对象继承自HashMap，但本身封装了一些基本的配置</span>        <span class="token comment" spellcheck="true">// 启动topology，本地启动使用LocalCluster，集群启动使用StormSubmitter</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>args <span class="token operator">==</span> null <span class="token operator">||</span> args<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 没有参数时使用本地模式，有参数时使用集群模式</span>            LocalCluster localCluster <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LocalCluster</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 本地开发模式，创建的对象为LocalCluster</span>            localCluster<span class="token punctuation">.</span><span class="token function">submitTopology</span><span class="token punctuation">(</span>topologyName<span class="token punctuation">,</span> config<span class="token punctuation">,</span> topology<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            StormSubmitter<span class="token punctuation">.</span><span class="token function">submitTopology</span><span class="token punctuation">(</span>topologyName<span class="token punctuation">,</span> config<span class="token punctuation">,</span> topology<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="2-将spout和bolt接口以及其他配置类组成的topology的jar包放入到指定的目录中（最好放在storm的nimbus节点下），注意打包方式确保JAR包下有storm-core相关依赖包"><a href="#2-将spout和bolt接口以及其他配置类组成的topology的jar包放入到指定的目录中（最好放在storm的nimbus节点下），注意打包方式确保JAR包下有storm-core相关依赖包" class="headerlink" title="2.将spout和bolt接口以及其他配置类组成的topology的jar包放入到指定的目录中（最好放在storm的nimbus节点下），注意打包方式确保JAR包下有storm-core相关依赖包."></a>2.将spout和bolt接口以及其他配置类组成的topology的jar包放入到指定的目录中（最好放在storm的nimbus节点下），注意打包方式确保JAR包下有storm-core相关依赖包.</h3><h3 id="3-执行命令提交topology的JAR到storm的集群"><a href="#3-执行命令提交topology的JAR到storm的集群" class="headerlink" title="3.执行命令提交topology的JAR到storm的集群"></a>3.执行命令提交topology的JAR到storm的集群</h3><pre class=" language-linux"><code class="language-linux">  #先切换到strom 的bin目录，然后执行以下命令  bin/storm kill topology #执行KILL操作时候可能会报没有此topology错误,可以不用理会    sleep 5  # 类似JAVA -JAR 方式启动JAR包，后面的bootstrap-servers根据业务而定，可要可不要.    bin/storm jar topology/topology-1.0.0.jar  com.company.ApplicationLoader --bootstrap-serverIp1=ip1:9092,serverIp2:9092,serverIp3:9092</code></pre><h3 id="4-通过nimbus的UI端口查看topology的运行情况，以及异常情况"><a href="#4-通过nimbus的UI端口查看topology的运行情况，以及异常情况" class="headerlink" title="4.通过nimbus的UI端口查看topology的运行情况，以及异常情况"></a>4.通过nimbus的UI端口查看topology的运行情况，以及异常情况</h3><p><img src="/images/stormui.png" alt=""></p><h2 id="storm-核心逻辑"><a href="#storm-核心逻辑" class="headerlink" title="storm 核心逻辑"></a>storm 核心逻辑</h2><blockquote><p>Nimbus：Storm集群主节点，负责资源分配和任务调度。我们提交任务和截止任务都是在Nimbus上操作的。一个Storm集群只有一个Nimbus节点。<br>Supervisor：Storm集群工作节点，接受Nimbus分配任务，管理所有Worker。<br>Worker：工作进程，每个工作进程中都有多个Task。<br>Task：任务，每个Spout和Bolt都是一个任务，每个任务都是一个线程。<br>Topology：计算拓扑，包含了应用程序的逻辑。<br>Stream：消息流，关键抽象，是没有边界的Tuple序列。<br>Spout：消息流的源头，Topology的消息生产者。<br>Bolt：消息处理单元，可以过滤、聚合、查询数据库。<br>Stream grouping：消息分发策略，一共6种，定义每个Bolt接受何种输入。<br>Reliability：可靠性，Storm保证每个Tuple都会被处理。</p></blockquote><h2 id="Storm安装部署"><a href="#Storm安装部署" class="headerlink" title="Storm安装部署"></a>Storm安装部署</h2><h3 id="zookeeper集群安装"><a href="#zookeeper集群安装" class="headerlink" title="zookeeper集群安装"></a>zookeeper集群安装</h3><blockquote><p>略，请自行查看文档安装，这个比较简单</p></blockquote><h3 id="搭建storm集群"><a href="#搭建storm集群" class="headerlink" title="搭建storm集群"></a>搭建storm集群</h3><p><a href="http://storm.apache.org/index.html" target="_blank" rel="noopener">下载storm包,目前已经更新到2.0版本，下载地址&gt;http://storm.apache.org/index.html</a></p><h3 id="1-解压"><a href="#1-解压" class="headerlink" title="1.解压"></a>1.解压</h3><pre class=" language-LINUX"><code class="language-LINUX">[uplooking@uplooking01 soft]$ tar -zxvf apache-storm-1.0.2.tar.gz -C ../app/[uplooking@uplooking01 app]$ mv apache-storm-1.0.2/ storm</code></pre><h3 id="2-修改配置文件-storm-env-sh"><a href="#2-修改配置文件-storm-env-sh" class="headerlink" title="2.修改配置文件 storm-env.sh"></a>2.修改配置文件 storm-env.sh</h3><pre class=" language-LINUX"><code class="language-LINUX">export JAVA_HOME=/opt/jdkexport STORM_CONF_DIR="/home/uplooking/app/storm/conf"</code></pre><h3 id="3-修改storm-yaml"><a href="#3-修改storm-yaml" class="headerlink" title="3. 修改storm.yaml"></a>3. 修改storm.yaml</h3><pre class=" language-LINUX"><code class="language-LINUX">storm.zookeeper.servers:    - "uplooking01"    - "uplooking02"    - "uplooking03"nimbus.seeds: ["uplooking01", "uplooking02"]storm.local.dir: "/home/uplooking/data/storm" # 日志目录supervisor.slots.ports:    - 6700    - 6701    - 6702    - 6703storm.zookeeper.port: 2181 #zookeeper端口配置ui.port: 8000 #ui 端口设置</code></pre><h3 id="4-创建storm-local-dir"><a href="#4-创建storm-local-dir" class="headerlink" title="4.创建storm.local.dir"></a>4.创建storm.local.dir</h3><pre class=" language-LINUX"><code class="language-LINUX">mkdir -p /home/uplooing/data/storm</code></pre><h3 id="5-配置环境变量"><a href="#5-配置环境变量" class="headerlink" title="5.配置环境变量"></a>5.配置环境变量</h3><pre class=" language-LINUX"><code class="language-LINUX"># .bash_profileexport STORM_HOME=/home/uplooking/app/stormexport PATH=$PATH:$STORM_HOME/bin</code></pre><h3 id="6-将其同步到其它节点"><a href="#6-将其同步到其它节点" class="headerlink" title="6.将其同步到其它节点"></a>6.将其同步到其它节点</h3><pre class=" language-LINUX"><code class="language-LINUX">scp .bash_profile uplooking@uplooking02:/home/uplookingscp .bash_profile uplooking@uplooking03:/home/uplooking</code></pre><h3 id="7-复制storm安装目录到其它节点"><a href="#7-复制storm安装目录到其它节点" class="headerlink" title="7.复制storm安装目录到其它节点"></a>7.复制storm安装目录到其它节点</h3><pre class=" language-linux"><code class="language-linux">scp -r storm/ uplooking@uplooking02:/home/uplooking/appscp -r storm/ uplooking@uplooking03:/home/uplooking/app</code></pre><h3 id="8-启动storm集群"><a href="#8-启动storm集群" class="headerlink" title="8.启动storm集群"></a>8.启动storm集群</h3><pre class=" language-linux"><code class="language-linux"># uplooking01storm nimbus &storm ui &# uplooking02storm nimbus &storm supervisor &# uplooking03storm supervisor &</code></pre><h3 id="9-启动logviewer（可选）"><a href="#9-启动logviewer（可选）" class="headerlink" title="9.启动logviewer（可选）"></a>9.启动logviewer（可选）</h3><pre class=" language-linux"><code class="language-linux">在所有从节点执行"nohup bin/storm logviewer >/dev/null 2>&1 &"启动log后台程序，并放到后台执行。(nimbus节点可以不用启动logviewer进程，因为logviewer进程主要是为了方便查看任务的执行日志，这些执行日志都在supervisor节点上)。</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>storm作为一款高效的数据流实时处理框架得到了广泛的使用，解决了Hadoop、spark在数据处理方面的性能问题，对JAVA良好的支持使得其在商业上应用更加广泛.<br>此文是自己学习和使用了storm集群的一些理解和体会，如有错误，欢迎指正.</p></blockquote><blockquote><p>一盏灯， 一片昏黄； <strong>一简书</strong>， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Storm </category>
          
          <category> Storm 集群 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Storm </tag>
            
            <tag> Topology </tag>
            
            <tag> Stream </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Netty-Nio</title>
      <link href="/2018/10/29/Netty-NIO-%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/10/29/Netty-NIO-%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>hello 小姐姐！this is my page for you. good afternoon.</p><a id="more"></a><p><img src="/images/mine.jpg" alt=""></p><blockquote><p>一盏灯， 一片昏黄； <strong>一简书</strong>， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nio </tag>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring-transactional-事务理解和使用</title>
      <link href="/2018/10/29/Spring-transactional-%E4%BA%8B%E5%8A%A1/"/>
      <url>/2018/10/29/Spring-transactional-%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<hr><h3 id="SPRING-transactional-简介"><a href="#SPRING-transactional-简介" class="headerlink" title="SPRING transactional 简介"></a>SPRING transactional 简介</h3><blockquote><p>事务管理是企业级应用程序开发中必不可少的技术，用来确保数据的完整性和一致性。<br>事务就是一系列的动作，它们被当作一个单独的工作单元，这些动作要么全部完成，要么全部不起作用.</p></blockquote><h3 id="事务的四个关键属性-ACID"><a href="#事务的四个关键属性-ACID" class="headerlink" title="事务的四个关键属性(ACID)"></a>事务的四个关键属性(ACID)</h3><blockquote><p>① 原子性(atomicity):事务是一个原子操作，有一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用.<br>② 一致性(consistency):一旦所有事务动作完成，事务就被提交。数据和资源就处于一种满足业务规则的一致性状态中.<br>③ 隔离性(isolation):可能有许多事务会同时处理相同的数据，因此每个事物都应该与其他事务隔离开来，防止数据损坏.<br>④ 持久性(durability):一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响。通常情况下，事务的结果被写到持久化存储器中.<br><a id="more"></a></p></blockquote><h3 id="事务回滚的触发机制"><a href="#事务回滚的触发机制" class="headerlink" title="事务回滚的触发机制"></a>事务回滚的触发机制</h3><h4 id="transaction注解"><a href="#transaction注解" class="headerlink" title="@transaction注解"></a>@transaction注解</h4><pre class=" language-java"><code class="language-java">    This annotation type is generally directly comparable to Spring's    <span class="token punctuation">{</span><span class="token annotation punctuation">@link</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>transaction<span class="token punctuation">.</span>interceptor<span class="token punctuation">.</span>RuleBasedTransactionAttribute<span class="token punctuation">}</span>    <span class="token keyword">class</span><span class="token punctuation">,</span> and in fact <span class="token punctuation">{</span><span class="token annotation punctuation">@link</span> AnnotationTransactionAttributeSource<span class="token punctuation">}</span> will directly    convert the data to the latter <span class="token keyword">class</span><span class="token punctuation">,</span> so that Spring's transaction support code    does not have to know about annotations<span class="token punctuation">.</span> If no rules are relevant to the exception<span class="token punctuation">,</span>    it will be treated like    <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">{</span><span class="token annotation punctuation">@link</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>transaction<span class="token punctuation">.</span>interceptor<span class="token punctuation">.</span>DefaultTransactionAttribute<span class="token punctuation">}</span>    <span class="token punctuation">(</span>rolling back on <span class="token punctuation">{</span><span class="token annotation punctuation">@link</span> RuntimeException<span class="token punctuation">}</span> and <span class="token punctuation">{</span><span class="token annotation punctuation">@link</span> Error<span class="token punctuation">}</span> but not on checked    exceptions<span class="token punctuation">)</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">.</span></code></pre><blockquote><p>星号包裹部分明确指出：事务<strong>默认</strong>会在runtimeException 和 error 回滚，但是checked exception 不会回滚.</p></blockquote><h3 id="checked-exception-和-unchecked-exception"><a href="#checked-exception-和-unchecked-exception" class="headerlink" title="checked exception 和 unchecked exception"></a>checked exception 和 unchecked exception</h3><blockquote><p>1.CheckedException已检查异常，CheckedException继承自Exception，程序内部无法控制，必须做处理，要么使用try-atch块捕获，要么throws抛给上一层。<br>正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。<br>除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，<br>也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</p></blockquote><blockquote><p>2.UnCheckedException未检查异常 ，UnCheckedException继承自RuntimeException，一般是程序的逻辑问题引起的异常，不需要捕获，也不需要处理, 比如空指针异常等。<br>包括运行时异常（RuntimeException与其子类）和错误（Error）。<br>运行时异常：都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，<br>这些异常是不检查异常，程序中可以选择捕&gt;获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。<br>运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。<br>非运行时异常 （编译异常）：是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。<br>如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p></blockquote><h3 id="异常的继承结构"><a href="#异常的继承结构" class="headerlink" title="异常的继承结构"></a>异常的继承结构</h3><p><img src="/images/exception.png" alt=""></p><blockquote><p>当方法抛出runtimeException 或者error时 事务会回滚.</p></blockquote><h3 id="如何在事务回滚前trycatch异常，处理后再回滚呢，可以尝试下面的这三种方式"><a href="#如何在事务回滚前trycatch异常，处理后再回滚呢，可以尝试下面的这三种方式" class="headerlink" title="如何在事务回滚前trycatch异常，处理后再回滚呢，可以尝试下面的这三种方式"></a>如何在事务回滚前trycatch异常，处理后再回滚呢，可以尝试下面的这三种方式</h3><pre class=" language-java"><code class="language-java">   SessionFactory sessionFactory <span class="token operator">=</span> hibernateTemplate<span class="token punctuation">.</span><span class="token function">getSessionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Session session <span class="token operator">=</span> sessionFactory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Transaction tx  <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">beginTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//开启事务</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//do something</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//do something 比如记录日志</span>            <span class="token comment" spellcheck="true">//第一种方式 </span>            tx<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//手动回滚事务</span>            <span class="token comment" spellcheck="true">//第二种方式</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"runtime"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//重新抛出触发事务回滚机制的异常类 RuntimeException 或者 error</span>      <span class="token comment" spellcheck="true">//第三种方式</span>      TransactionAspectSupport<span class="token punctuation">.</span><span class="token function">currentTransactionStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setRollbackOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><h3 id="Transactional-注解也可以添加到类级别上的使用"><a href="#Transactional-注解也可以添加到类级别上的使用" class="headerlink" title="@Transactional 注解也可以添加到类级别上的使用"></a>@Transactional 注解也可以添加到类级别上的使用</h3><blockquote><p>当把@Transactional 注解放在类级别时，表示所有该类的公共方法都配置相同的事务属性信息。EmployeeService 的所有方法都支持事务并且是只读。<br>当类级别配置了@Transactional，方法级别也配置了@Transactional时，应用程序会以方法级别的事务属性信息来管理事务。</p></blockquote><pre class=" language-java"><code class="language-java">  <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation<span class="token operator">=</span> Propagation<span class="token punctuation">.</span>SUPPORTS<span class="token punctuation">,</span>readOnly<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">)</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation<span class="token operator">=</span> Propagation<span class="token punctuation">.</span>REQUIRED<span class="token punctuation">,</span>readOnly<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//方法级别的事务属性信息会覆盖类级别的相关配置信息。</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation<span class="token operator">=</span> Propagation<span class="token punctuation">.</span>REQUIRED<span class="token punctuation">,</span>readOnly<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><h3 id="Spring-的注解方式的事务实现机制"><a href="#Spring-的注解方式的事务实现机制" class="headerlink" title="Spring 的注解方式的事务实现机制"></a>Spring 的注解方式的事务实现机制</h3><blockquote><blockquote><p>在应用系统调用声明@Transactional 的目标方法时，Spring Framework 默认使用 AOP 代理，在代码运行时生成一个代理对象，根据@Transactional 的属性配置信息，这个代理对象决定该声明@Transactional 的目标方法是否由拦截器 TransactionInterceptor 来使用拦截，在 TransactionInterceptor 拦截时，会在在目标方法开始执行之前创建并加入事务，并执行目标方法的逻辑, 最后根据执行情况是否出现异常，利用抽象事务管理器(图 2 有相关介绍)AbstractPlatformTransactionManager 操作数据源 DataSource 提交或回滚事务<br>Spring AOP 代理有 CglibAopProxy 和 JdkDynamicAopProxy 两种，图 1 是以 CglibAopProxy 为例，对于 CglibAopProxy，需要调用其内部类的 DynamicAdvisedInterceptor 的 intercept 方法。对于 JdkDynamicAopProxy，需要调用其 invoke 方法。<br>正如上文提到的，事务管理的框架是由抽象事务管理器 AbstractPlatformTransactionManager 来提供的，而具体的底层事务处理实现，由 PlatformTransactionManager 的具体实现类来实现，如事务管理器 DataSourceTransactionManager。不同的事务管理器管理不同的数据资源 DataSource，比如 DataSourceTransactionManager 管理 JDBC 的 Connection。<br>PlatformTransactionManager，AbstractPlatformTransactionManager 及具体实现类关系如图 2 所示。</p></blockquote></blockquote><h3 id="transactional-的属性和使用"><a href="#transactional-的属性和使用" class="headerlink" title="transactional 的属性和使用"></a>transactional 的属性和使用</h3><blockquote><p>name    当在配置文件中有多个 TransactionManager , 可以用该属性指定选择哪个事务管理器。<br>propagation    事务的传播行为，默认值为 REQUIRED。<br>isolation    事务的隔离度，默认值采用 DEFAULT。<br>timeout    事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。<br>read-only    指定事务是否为只读事务，默认值为 false；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。<br>rollback-for    用于指定能够触发事务回滚的异常类型，如果有多个异常类型需要指定，各类型之间可以通过逗号分隔。<br>no-rollback- for    抛出 no-rollback-for 指定的异常类型，不回滚事务。</p></blockquote><h4 id="正确的设置-Transactional-的-propagation-属性"><a href="#正确的设置-Transactional-的-propagation-属性" class="headerlink" title="正确的设置@Transactional 的 propagation 属性"></a>正确的设置@Transactional 的 propagation 属性</h4><blockquote><blockquote><p>需要注意下面三种 propagation 可以不启动事务。本来期望目标方法进行事务管理，但若是错误的配置这三种 propagation，事务将不会发生回滚。<br>1 TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。<br>2 TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。<br>3 TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。</p></blockquote></blockquote><h4 id="正确的设置-Transactional-的-rollbackFor-属性"><a href="#正确的设置-Transactional-的-rollbackFor-属性" class="headerlink" title="正确的设置@Transactional 的 rollbackFor 属性"></a>正确的设置@Transactional 的 rollbackFor 属性</h4><pre class=" language-java"><code class="language-java"> <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation<span class="token operator">=</span> Propagation<span class="token punctuation">.</span>REQUIRED<span class="token punctuation">,</span>rollbackFor<span class="token operator">=</span> MyException<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span></code></pre><blockquote><p>默认情况下，如果在事务中抛出了未检查异常（继承自 RuntimeException 的异常）或者 Error，则 Spring 将回滚事务；除此之外，Spring 不会回滚事务。<br>如果在事务中抛出其他类型的异常，并期望 Spring 能够回滚事务，可以指定 rollbackFor。<br>通过分析 Spring 源码可以知道，若在目标方法中抛出的异常是 rollbackFor 指定的异常的子类，事务同样会回滚。</p></blockquote><h3 id="Transactional-和aop"><a href="#Transactional-和aop" class="headerlink" title="Transactional 和aop"></a>Transactional 和aop</h3><p>只有@Transactional 注解应用到 public 方法，才能进行事务管理。这是因为在使用 Spring AOP 代理时，Spring 在调用在图 1 中的 TransactionInterceptor 在目标方法执行前后进行拦截之前，DynamicAdvisedInterceptor（CglibAopProxy 的内部类）的的 intercept 方法或 JdkDynamicAopProxy 的 invoke 方法会间接调用 AbstractFallbackTransactionAttributeSource（Spring 通过这个类获取表 1. @Transactional 注解的事务属性配置属性信息）的 computeTransactionAttribute 方法。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> TransactionAttribute <span class="token function">computeTransactionAttribute</span><span class="token punctuation">(</span>Method method<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> targetClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Don't allow no-public methods as required.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">allowPublicMethodsOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>Modifier<span class="token punctuation">.</span><span class="token function">isPublic</span><span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>这个方法会检查目标方法的修饰符是不是 public，若不是 public，就不会获取@Transactional 的属性配置信息，最终会造成不会用 TransactionInterceptor 来拦截该目标方法进行事务管理。</p></blockquote><h4 id="如何解决AOP事务失效问题"><a href="#如何解决AOP事务失效问题" class="headerlink" title="如何解决AOP事务失效问题"></a>如何解决AOP事务失效问题</h4><blockquote><p>在 Spring 的 AOP 代理下，只有目标方法由外部调用，目标方法才由 Spring 生成的代理对象来管理，这会造成自调用问题。若同一类中的其他没有@Transactional 注解的方法内部调用有@Transactional 注解的方法，有@Transactional 注解的方法的事务被忽略，不会发生回滚<br><code>`</code>java<br>@Service<br>public class OrderService {<br>    private void insert() {<br>      insertOrder();<br>    }</p></blockquote><p>@Transactional<br>    public void insertOrder() {<br>        //do something<br>     }<br>}</p><pre><code>&gt;insertOrder 尽管有@Transactional 注解，但它被内部方法 insert 调用，事务被忽略，出现异常事务不会发生回滚。上面的两个问题@Transactional 注解只应用到 public 方法和自调用问题，是由于使用 Spring AOP 代理造成的。为解决这两个问题，使用 AspectJ 取代 Spring AOP 代理。#### 解决办法&gt;1 添加ASPECTJ XML配置``` XML  &lt;tx:annotation-driven mode=&quot;aspectj&quot; /&gt;  &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;  &lt;/bean&gt;  &lt;/bean  class=&quot;org.springframework.transaction.aspectj.AnnotationTransactionAspect&quot; factory-method=&quot;aspectOf&quot;&gt;    &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot; /&gt;  &lt;/bean&gt;</code></pre><blockquote><p>2 同时在 Maven 的 pom 文件中加入 spring-aspects 和 aspectjrt 的 dependency 以及 aspectj-maven-plugin。<br><code>`</code> XML</p></blockquote><p><dependency><br>  <groupid>org.springframework</groupid><br>  <artifactid>spring-aspects</artifactid><br>  <version>4.3.2.RELEASE</version><br></dependency></p><p><dependency><br>  <groupid>org.aspectj</groupid><br>  <artifactid>aspectjrt</artifactid><br>  <version>1.8.9</version><br></dependency></p><p><plugin></plugin></p><p><groupid>org.codehaus.mojo</groupid></p><p><artifactid>aspectj-maven-plugin</artifactid></p><p><version>1.9</version></p><p><configuration></configuration></p><p><showweaveinfo>true</showweaveinfo></p><p><aspectlibraries><br>  <aspectlibrary><br>    <groupid>org.springframework</groupid><br>    <artifactid>spring-aspects</artifactid><br>  </aspectlibrary><br></aspectlibraries><br></p><p><executions><br>  <execution><br>  <goals><br>    <goal>compile</goal><br>    <goal>test-compile</goal><br>  </goals><br>  </execution><br></executions><br><br><code>`</code></p><hr><p><a href="https://www.ibm.com/developerworks/cn/java/j-master-spring-transactional-use/index.html" target="_blank" rel="noopener">参考https://www.ibm.com/developerworks/cn/java/j-master-spring-transactional-use/index.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Transaction </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Thread-pool-多线程并发</title>
      <link href="/2018/10/29/Thread-pool-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/"/>
      <url>/2018/10/29/Thread-pool-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h3 id="多线程简介"><a href="#多线程简介" class="headerlink" title="多线程简介"></a>多线程简介</h3><blockquote><p>多线程适合多种开发语言的开发, 这是一种思想，基于的是操作系统底层的CPU调度.<br>  此篇介绍线程、多线程、和线程池的使用和机制。<br><a id="more"></a></p></blockquote><h3 id="进程-线程"><a href="#进程-线程" class="headerlink" title="进程\线程"></a>进程\线程</h3><ol><li>进程<blockquote><p>1 进程 是指在系统中正在运行的一个应用程序, 每一个进程都有一个PID， 当进程占用太多资源或者卡死的时候，CPU会强杀掉进程。<br>2 每个进程之间是独立的，每个进程均运行在其专用的且受保护的内存空间内。</p></blockquote></li><li>线程<blockquote><p>1 个进程由多个线程组成(1个进程至少要有1个线程)。<br>2 线程是进程的基本执行单元，一个进程的所有任务都在线程中执行。</p></blockquote></li></ol><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><ol><li>多线程<blockquote><p>1个进程中可以开启多个线程，多个线程可以同时执行不同的任务, 多线程一般情况下可以提高程序的执行效率。</p></blockquote></li><li>多线程原理<blockquote><p>对于单核CPU来说，同一时间，CPU只能处理1个线程，只有1个线程正在执行，现在大部分CPU都是4核8线程。<br>   多线程同时执行的本质：是CPU快速的在多个线程之间的切换，这个时间非常的短在毫秒级别，以至于用户无法察觉。<br>   CPU调度线程的时间足够快，就造成了多线程的“同时”执行。<br>   如果线程数非常多，CPU会在n个线程之间切换，消耗大量的CPU资源，每个线程被调度的次数会降低，线程的执行效率降低。</p></blockquote></li><li>多线程的优点<blockquote><p>能适当提高程序的执行效率，但是在业务简单时，单线程会比多线程更快。<br>  能适当提高资源的利用率(CPU、内存)。<br>  线程上的任务执行完成后，线程会自动销毁。</p></blockquote></li><li>多线程的缺点<blockquote><p>开启线程需要占用一定的内存空间(默认情况下，每一个线程都占用512KB)，如果开启大量的线程，会占用大量的内存空间，降低程序的性能。<br>  线程越多，CPU在调用线程上的开销就越大。<br>  程序设计更加复杂，比如线程间的通信、多线程的数据共享。</p></blockquote></li><li>主线程<blockquote><p>一个程序运行后，默认会开启1个线程，称为“主线程”或“UI线程”，java中的main方法就是一个程序的主线程，如果这个方法体中的业务逻辑存在while循环、线程池<br> 、websorcket等阻塞程序的，那么会使main方法阻塞，程序则不会退出，这也是程序正常运行不退出的原因；一些简单类的main方法会退出是因为并没有阻塞main方法。<br> 主线程一般用来刷新UI界面，处理UI事件。<br> 主线程使用注意：别将耗时的操作放到主线程中，因为耗时操作会卡住主线程，严重影响UI的流畅度，给用户一种卡的坏体验。</p></blockquote></li></ol><h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><ol><li>同步执行<blockquote><p>写程序的时候都是从上到下，从左到右，代码执行顺序也是从上到下从右到左。<br> 1个线程执行多个任务，也是依次执行a-&gt;b-&gt;c。<br> 1个线程同一时间执行1个任务。</p></blockquote></li><li>异步执行<blockquote><p>多个线程可以同时执行多个任务。<br>  多个线程执行多个任务可以同时执行a，b，c。</p></blockquote></li><li>synchronized<blockquote><p>同步块大家都比较熟悉，通过 synchronized 关键字来实现；所有加上 synchronized 的方法和块语句，在多线程访问的时候，同一时刻只能有一个线程能够访问。</p></blockquote></li><li>wait()、notify()、notifyAll()<blockquote><p>这三个方法是 java.lang.Object 的 final native 方法，任何继承 java.lang.Object 的类都有这三个方法。<br>  它们是Java语言提供的实现线程间阻塞和控制进程内调度的底层机制，平时我们会很少用到的。</p></blockquote></li><li>wait()：<blockquote><p>导致线程进入等待状态，直到它被其他线程通过notify()或者notifyAll唤醒，该方法只能在同步方法中调用。</p></blockquote></li><li>notify()：<blockquote><p>随机选择一个在该对象上调用wait方法的线程，解除其阻塞状态，该方法只能在同步方法或同步块内部调用。</p></blockquote></li><li>notifyAll()：<blockquote><p>解除所有那些在该对象上调用wait方法的线程的阻塞状态，同样该方法只能在同步方法或同步块内部调用。<br>  调用这三个方法中任意一个，当前线程必须是锁的持有者，如果不是会抛出一个 IllegalMonitorStateException 异常。</p></blockquote></li><li>wait()与Thread.sleep(long time)的区别<blockquote><p>sleep()   ：方法在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），该线程不丢失任何监视器的所属权，sleep() 是 Thread 类专属的静态方法，针对一个特定的线程。<br>  wait()    : 方法使实体所处线程暂停执行，从而使对象进入等待状态，直到被 notify() 方法通知或者 wait() 的等待的时间到。<br>  sleep()   : 方法使持有的线程暂停运行，从而使线程进入休眠状态，直到用interrupt 方法来打断他的休眠或者 sleep 的休眠的时间到。<br>  wait()    : 方法进入等待状态时会释放同步锁，而 sleep() 方法不会释放同步锁。所以，当一个线程无限 sleep 时又没有任何人去 interrupt 它的时候，程序就产生大麻烦了。<br>  notify()  : 是用来通知线程，但在 notify() 之前线程是需要获得 lock 的。另个意思就是必须写在 synchronized(lockobj) {…} 之中。<br>  wait()    : 也是这个样子，一个线程需要释放某个 lock，也是在其获得 lock 情况下才能够释放，所以 wait() 也需要放在 synchronized(lockobj) {…} 之中。</p></blockquote></li><li>volatile 关键字<blockquote><p>volatile 是一个特殊的修饰符，只有成员变量才能使用它。在Java并发程序缺少同步类的情况下，多线程对成员变量的操作对其它线程是透明的。<br>  volatile 变量可以保证下一个读取操作会在前一个写操作之后发生。线程都会直接从内存中读取该变量并且不缓存它。这就确保了线程读取到的变量是同内存中是一致的。</p></blockquote></li><li>ThreadLocal 变量<blockquote><p>ThreadLocal 是Java里一种特殊的变量。每个线程都有一个 ThreadLocal 就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。<br>  如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。首先，通过复用减少了代价高昂的对象的创建个数。<br>  其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。</p></blockquote></li><li><p>Join() 方法</p><blockquote><p>join() 方法定义在 Thread 类中，所以调用者必须是一个线程，join() 方法主要是让调用该方法的 Thread 完成 run() 方法里面的东西后，再执行 join() 方法后面的代码。</p></blockquote><pre class=" language-java"><code class="language-java">    Thread t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>计数线程一<span class="token punctuation">)</span><span class="token punctuation">;</span>      Thread t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>计数线程二<span class="token punctuation">)</span><span class="token punctuation">;</span>      t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 等待计数线程一执行完成，再执行计数线程二</span>    t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre><blockquote><p>启动 t1 后，调用了 join() 方法，直到 t1 的计数任务结束，才轮到 t2 启动，然后 t2 才开始计数任务，两个线程是按着严格的顺序来执行的。<br>  如果 t2 的执行需要依赖于 t1 中的完整数据的时候，这种方法就可以很好的确保两个线程的同步性。</p></blockquote></li><li>Thread.yield() 方法<blockquote><p>Thread.sleep(long time)：线程暂时终止执行（睡眠）一定的时间。<br>  Thread.yield()：线程放弃运行，将CPU的控制权让出。<br>  这两个方法都会将当前运行线程的CPU控制权让出来，但 sleep() 方法在指定的睡眠时间内一定不会再得到运行机会，直到它的睡眠时间完成；<br>  而 yield() 方法让出控制权后，还有可能马上被系统的调度机制选中来运行，比如，执行yield()方法的线程优先级高于其他的线程，那么这个线程即使执行了 yield() 方法也可能不能起到让出CPU控制权的效果，因为它让出控制权后，进入排队队列，调度机制将&gt;从等待运行的线程队列中选出一个等级最高的线程来运行，那么它又（很可能）被选中来运行。</p></blockquote></li></ol><h3 id="Java-多线程的实现的三种方式"><a href="#Java-多线程的实现的三种方式" class="headerlink" title="Java 多线程的实现的三种方式"></a>Java 多线程的实现的三种方式</h3><ol><li>继承thread方式<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">newThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//do something</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//do something</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>Thread 类中的 start() 和 run() 方法有什么区别<br>调用 start() 方法才会启动新线程；如果直接调用 Thread 的 run() 方法，它的行为就会和普通的方法一样；为了在新的线程中执行我们的代码，必须使用 Thread.start() 方法。</p></blockquote></li><li>实现runable接口方式<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NewThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//do something</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li>继承thread其实也是实现runable接口的方式实现的<br><img src="/images/thread.png" alt=""></li><li><p>实现callable接口</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NewCallableThread</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//String 是线程的返回值类型</span>    <span class="token keyword">private</span> String threadName<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Object obj<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">NewCallableThread</span><span class="token punctuation">(</span>String threadName<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">,</span> Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>threadName <span class="token operator">=</span> threadName<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> count<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>obj   <span class="token operator">=</span> obj<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>count <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                count <span class="token operator">++</span><span class="token punctuation">;</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>threadName <span class="token operator">+</span> <span class="token string">">count>"</span> <span class="token operator">+</span> count <span class="token operator">+</span><span class="token string">"object is "</span> <span class="token operator">+</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token string">"这是返回值"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//callable接口可以返回线程的执行结果,也可以抛出异常，例如此线程处理完的数据结果可返回给调用者，但是线程不会释放资源直到拿到返回值，所以如果不需要返回return null即可</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        NewCallableThread thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NewCallableThread</span><span class="token punctuation">(</span><span class="token string">"thread1"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        thread1<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        NewCallableThread thread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NewCallableThread</span><span class="token punctuation">(</span><span class="token string">"thread2"</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread2<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>单线程和多线程演示</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NewThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String threadName<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Object obj<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//obj 是任何类型的可将此对象传入线程中使用</span>    <span class="token keyword">public</span> <span class="token function">NewThread</span><span class="token punctuation">(</span>String threadName<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">,</span> Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>threadName <span class="token operator">=</span> threadName<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> count<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>obj   <span class="token operator">=</span> obj<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>count <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                count <span class="token operator">++</span><span class="token punctuation">;</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>threadName <span class="token operator">+</span> <span class="token string">">count>"</span> <span class="token operator">+</span> count <span class="token operator">+</span><span class="token string">"object is "</span> <span class="token operator">+</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        NewThread thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NewThread</span><span class="token punctuation">(</span><span class="token string">"thread1"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        thread1<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        NewThread thread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NewThread</span><span class="token punctuation">(</span><span class="token string">"thread2"</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread2<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>thread1、thread2都是单独的一个线程,都是由CPU调度执行</p></blockquote></li><li><p>附runable和callable的接口源码</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token punctuation">{</span>     V <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>runable和callable的对比</p><blockquote><p>Callable 接口下的方法是 call()，Runnable 接口的方法是 run()。<br>   Callable 的任务执行后可返回值，而 Runnable 的任务是不能返回值的。<br>   call() 方法可以抛出异常，run()方法不可以的。<br>   运行 Callable 任务可以拿到一个 Future 对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。<br>   通过 Future 对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。</p></blockquote></li><li><p>附future接口的源码</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Future</span><span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token punctuation">{</span>     <span class="token keyword">boolean</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> mayInterruptIfRunning<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">boolean</span> <span class="token function">isCancelled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">boolean</span> <span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     V <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span> ExecutionException<span class="token punctuation">;</span>     V <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span> ExecutionException<span class="token punctuation">,</span> TimeoutException<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><blockquote><p>boolean cancel(boolean mayInterruptIfRunning);<br>   此方法试图取消对此任务的执行。<strong>[任务已完成、已取消，或者由于某些其他原因而无法取消，则此尝试将失败，cancel调用成功后，isCancelled和isDone将始终返回true]</strong>，<br>   mayInterruptIfRunning 参数确定是否应该使用试图停止任务的方式来中断执行此任务的线程</p></blockquote><blockquote><p>boolean isCancelled(); 如果在任务正常完成前将其取消，则返回 true</p></blockquote><blockquote><p>boolean isDone(); 任务是否已完成</p></blockquote><blockquote><p>V get() throws InterruptedException, ExecutionException; 如有必要等待线程执行完毕，获取返回结果</p></blockquote><blockquote><p>V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; 在规定时间内等待线程执行完毕，获取返回结果</p></blockquote></li><li><p>FutureTask-Thread的设计优化</p><pre class=" language-java"><code class="language-java">     <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">RunnableFuture</span><span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token punctuation">{</span>         <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">RunnableFuture</span><span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Runnable</span><span class="token punctuation">,</span> Future<span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token punctuation">{</span>         <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span></code></pre><blockquote><p>FutureTask 实现了 Runnable 和 Future，所以兼顾两者优点，既可以在 Thread 中使用，又可以在 ExecutorService 中使用。</p></blockquote><pre class=" language-java"><code class="language-java">     Callable<span class="token operator">&lt;</span>String<span class="token operator">></span> callable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token annotation punctuation">@Override</span>         <span class="token keyword">public</span> String <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>             <span class="token keyword">return</span> <span class="token string">"something"</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span><span class="token punctuation">;</span>     FutureTask<span class="token operator">&lt;</span>String<span class="token operator">></span> task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span>callable<span class="token punctuation">)</span><span class="token punctuation">;</span>     Thread t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>     t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 启动线程</span>     task<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 取消线程</span></code></pre><blockquote><p>使用 FutureTask 的好处是 FutureTask 弥补了Thread 的不足，它可以让调用者准确地知道线程什么时候执行完成并获得线程执行完成后的返回结果。<br>FutureTask 是一种可以取消的异步的计算任务，它的计算是通过 Callable 实现的，它等价于可以携带结果的 Runnable，并且有三个状态：等待、运行和完成。<br>完成包括所有计算以任意的方式结束，包括正常结束、取消和异常。</p></blockquote></li></ol><hr><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ol><li>线程池简介<blockquote><p>Java里面线程池的顶级接口是 Executor，不过真正的线程池接口是 ExecutorService， ExecutorService 的默认实现是 ThreadPoolExecutor；<br>   普通类 Executors 里面调用的就是 ThreadPoolExecutor。</p></blockquote></li><li><p>线程池的优点</p><blockquote><p>1 避免线程的创建和销毁带来的性能开销。<br>   2 避免大量的线程间因互相抢占系统资源导致的阻塞现象。<br>   3 能够对线程进行简单的管理并提供定时执行、间隔执行等功能。</p></blockquote></li><li><p>如何初始化一个线程池</p><pre class=" language-java"><code class="language-java">     <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NewPool</span> <span class="token punctuation">{</span>         <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> corePoolSize <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>         <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> maximumPoolSize <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>         <span class="token keyword">final</span> <span class="token keyword">static</span> BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">private</span> <span class="token keyword">static</span> ExecutorService pool <span class="token operator">=</span> null<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//初始化线程池</span>         <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">initPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>             pool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> maximumPoolSize<span class="token punctuation">,</span> 0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span> workQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//或者使用Executors创建线程池</span>             <span class="token comment" spellcheck="true">//pool = Executors.newSingleThreadExecutor();</span>             <span class="token comment" spellcheck="true">//pool = Executors.newCachedThreadPool();</span>             <span class="token comment" spellcheck="true">//pool = Executors.newFixedThreadPool(5);</span>             <span class="token comment" spellcheck="true">//pool = Executors.newScheduledThreadPool(5);</span>         <span class="token punctuation">}</span>         <span class="token comment" spellcheck="true">//当有新的数据时调用poolAddThread(String,int,Object obj)处理传入的数据，</span>         <span class="token comment" spellcheck="true">//例如如obj, object就相当于数据</span>         <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">poolAddThread</span><span class="token punctuation">(</span>String threadName<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">,</span> Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>             NewThread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NewThread</span><span class="token punctuation">(</span>threadName<span class="token punctuation">,</span> count<span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>             pool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span>             NewCallableThread callThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NewCallableThread</span><span class="token punctuation">(</span>threadName<span class="token punctuation">,</span> count<span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>             pool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>callThread<span class="token punctuation">)</span><span class="token punctuation">;</span>             pool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>             <span class="token function">initPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span></code></pre><blockquote><p>execute 和submit的区别在于submit可以抛出异常和返回结果，给外部调用者处理，例如某一个task失败则终止其他task执行，或者shutdown线程池.</p></blockquote></li><li><p>线程池分类及比较-Executors 提供四种线程池</p><blockquote><p>newCachedThreadPool<br>   可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。<br>   调用 execute() 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中,<br>   终止并从缓存中移除那些已有 60 秒钟未被使用的线程。<br>   因此，长时间保持空闲的线程池不会使用任&gt;何资源。注意，可以使用 ThreadPoolExecutor 构造方法创建具有类似属性但细节不同（例如超时参数）的线程池。</p></blockquote><blockquote><p>newSingleThreadExecutor<br>   创建一个单线程池，也就是该线程池只有一个线程在工作，所有的任务是串行执行的，如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它，<br>   此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p></blockquote><blockquote><p>newFixedThreadPool<br>   创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小，线程池的大小一旦达到最大值就会保持不变，<br>   如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</p></blockquote><blockquote><p>newScheduledThreadPool<br>   创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。</p></blockquote><pre class=" language-java"><code class="language-java">     <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Executor</span> <span class="token punctuation">{</span>         <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ExecutorService</span> <span class="token keyword">extends</span> <span class="token class-name">Executor</span> <span class="token punctuation">{</span>         <span class="token keyword">void</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         List<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> <span class="token function">shutdownNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">boolean</span> <span class="token function">isShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">boolean</span> <span class="token function">isTerminated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token operator">&lt;</span>T<span class="token operator">></span> Future<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">submit</span><span class="token punctuation">(</span>Callable<span class="token operator">&lt;</span>T<span class="token operator">></span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token operator">&lt;</span>T<span class="token operator">></span> Future<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">submit</span><span class="token punctuation">(</span>Runnable task<span class="token punctuation">,</span> T result<span class="token punctuation">)</span><span class="token punctuation">;</span>         Future<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">submit</span><span class="token punctuation">(</span>Runnable task<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Executors</span> <span class="token punctuation">{</span>         <span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                 <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span> 60L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                                  <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token comment" spellcheck="true">//...</span>     <span class="token punctuation">}</span></code></pre></li><li><p>ThreadPoolExecutor构造函数</p><pre class=" language-java"><code class="language-java">     <span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                             <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>                             <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>                             TimeUnit unit<span class="token punctuation">,</span>                             BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>                             ThreadFactory threadFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">this</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> maximumPoolSize<span class="token punctuation">,</span> keepAliveTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> workQueue<span class="token punctuation">,</span>              threadFactory<span class="token punctuation">,</span> defaultHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span></code></pre><blockquote><p>1 corePoolSize：线程池的核心线程数，一般情况下不管有没有任务都会一直在线程池中一直存活，只有在 ThreadPoolExecutor 中的方法<br>   allowCoreThreadTimeOut(boolean value) 设置为 true 时，闲置的核心线程会存在超时机制，如果在指定时间没有新任务来时，<br>   核心线程也会被终止，而这个时间间隔由第3个属性 keepAliveTime 指定。</p></blockquote><blockquote><p>2 maximumPoolSize：线程池所能容纳的最大线程数，当活动的线程数达到这个值后，后续的新任务将会被阻塞。</p></blockquote><blockquote><p>3 keepAliveTime：控制线程闲置时的超时时长，超过则终止该线程。一般情况下用于非核心线程，<br>   只有在 ThreadPoolExecutor 中的方法 allowCoreThreadTimeOut(boolean value) 设置为 true时，也作用于核心线程。</p></blockquote><blockquote><p>4 unit：用于指定 keepAliveTime 参数的时间单位，TimeUnit 是个 enum 枚举类型，常用的有：TimeUnit.HOURS(小时)、TimeUnit.MINUTES(分钟)、<br>   TimeUnit.SECONDS(秒) 和TimeUnit.MILLISECONDS(毫秒)等。</p></blockquote><blockquote><p>5 workQueue：线程池的任务队列，通过线程池的 execute(Runnable command) 方法会将任务 Runnable 存储在队列中，之后我会出一个submit和excute的详细对比。</p></blockquote><blockquote><p>6 threadFactory：线程工厂，它是一个接口，用来为线程池创建新线程的。</p></blockquote></li><li><p>线程池的关闭</p><blockquote><p>ThreadPoolExecutor 提供了两个方法，用于线程池的关闭，分别是 shutdown() 和 shutdownNow()。<br>   shutdown()：不会立即的终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务。<br>   shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务。</p></blockquote></li></ol><hr><p><a href="https://www.jianshu.com/p/b8197dd2934c" target="_blank" rel="noopener">参考https://www.jianshu.com/p/b8197dd2934c</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Thread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> pool </tag>
            
            <tag> Synchronized </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
