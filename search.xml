<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>如何使用hibernate.jdbc.Work批量插入数据</title>
      <link href="/2019/01/18/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%94%9FJDBC%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/"/>
      <url>/2019/01/18/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%94%9FJDBC%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文介绍如何使用hibernate.jdbc.Work批量处理大量的数据插入工作<br><a id="more"></a></p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>为何使用原生的批量处理数据操作而不用现有的hibernate框架实现呢，因为hibernate对插入和更新的处理方式在大量数据插入式并不能更好的支持。</p></blockquote><blockquote><p>需求分析，如果你希望将一个对象的集合全部插入到数据库，但使用hibernate框架的批处理速度回比较慢，hibernate其实是一条一条的插入数据的，JDBC的BATCH不同是JDBC的bactch会先将sql预编译，再将集合的值SET进去，大大节省了编译SQL的时间。</p></blockquote><blockquote><p>经过测试：使用hibernate插入10条数据，需要预编译SQL10次，而原始JDBC的batch只需要预编译一次，且随着需要插入的数据增长需要的时间区别也越来越大，使用hibernate默认batch插入10000条数据需要1-2秒，优化后只需要200毫秒左右.</p></blockquote><h2 id="hibernate-de-persist-he-merge"><a href="#hibernate-de-persist-he-merge" class="headerlink" title="hibernate de persist he merge"></a>hibernate de persist he merge</h2><pre class=" language-java"><code class="language-java"> <span class="token comment" spellcheck="true">/**     * Make an instance managed and persistent.     * @param entity  entity instance     * @throws EntityExistsException if the entity already exists.     * (If the entity already exists, the &lt;code>EntityExistsException&lt;/code> may     * be thrown when the persist operation is invoked, or the     * &lt;code>EntityExistsException&lt;/code> or another &lt;code>PersistenceException&lt;/code> may be     * thrown at flush or commit time.)     * @throws IllegalArgumentException if the instance is not an     *         entity     * @throws TransactionRequiredException if invoked on a     *         container-managed entity manager of type     *         &lt;code>PersistenceContextType.TRANSACTION&lt;/code> and there is     *         no transaction     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">persist</span><span class="token punctuation">(</span>Object entity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * Merge the state of the given entity into the     * current persistence context.     * @param entity  entity instance     * @return the managed instance that the state was merged to     * @throws IllegalArgumentException if instance is not an     *         entity or is a removed entity     * @throws TransactionRequiredException if invoked on a     *         container-managed entity manager of type     *         &lt;code>PersistenceContextType.TRANSACTION&lt;/code> and there is     *         no transaction     */</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">merge</span><span class="token punctuation">(</span>T entity<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="通过Hibernate的缓存进行批量插入"><a href="#通过Hibernate的缓存进行批量插入" class="headerlink" title="通过Hibernate的缓存进行批量插入"></a>通过Hibernate的缓存进行批量插入</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HibernateTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        SessionFactory sessionFactory <span class="token operator">=</span> hibernateTemplate<span class="token punctuation">.</span><span class="token function">getSessionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Session session <span class="token operator">=</span> sessionFactory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Transaction tx  <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">beginTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//开启事务</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">50</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Usertable user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Usertable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            user<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"100"</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            session<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">%</span><span class="token number">100</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                session<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  session<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        ts<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        HibernateSessionFactory<span class="token punctuation">.</span><span class="token function">closeSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="直接调用JDBC"><a href="#直接调用JDBC" class="headerlink" title="直接调用JDBC"></a>直接调用JDBC</h2><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>rollbackFor <span class="token operator">=</span> Exception<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> RpcServiceResult <span class="token function">createSubThings</span><span class="token punctuation">(</span>ArrayNode insertArray<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SessionFactory sessionFactory <span class="token operator">=</span> hibernateTemplate<span class="token punctuation">.</span><span class="token function">getSessionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Session session <span class="token operator">=</span> sessionFactory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Transaction tx  <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">beginTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//开启事务</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//do something</span>            String sqlStr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"INSERT INTO  table       ( `attribute1`,"</span>                                                                <span class="token operator">+</span> <span class="token string">" `attribute2`, "</span>                                                                <span class="token operator">+</span> <span class="token string">" `attribute3`"</span>                                                                <span class="token operator">+</span> <span class="token string">") "</span>                                    <span class="token operator">+</span>  <span class="token string">"VALUES (?, ?, ?);"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Work work <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Work</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//Contract for performing a discrete piece of org.hibernate.jdbc.Work;</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Connection connection<span class="token punctuation">)</span> <span class="token keyword">throws</span> SQLException <span class="token punctuation">{</span>                    PreparedStatement statement <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sqlStr<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> insertArray<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        JsonNode subThingJsonNode <span class="token operator">=</span> insertArray<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                        String value1     <span class="token operator">=</span> subThingJsonNode<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"key1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">asText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        String value2   <span class="token operator">=</span> subThingJsonNode<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"key2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">asText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        String value3   <span class="token operator">=</span> subThingJsonNode<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"key3"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">asText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        statement<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>value1<span class="token punctuation">)</span><span class="token punctuation">;</span>                        statement<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>value2<span class="token punctuation">)</span><span class="token punctuation">;</span>                        statement<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span>value3<span class="token punctuation">)</span><span class="token punctuation">;</span>                        statement<span class="token punctuation">.</span><span class="token function">addBatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    statement<span class="token punctuation">.</span><span class="token function">executeBatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span>            session<span class="token punctuation">.</span><span class="token function">doWork</span><span class="token punctuation">(</span>work<span class="token punctuation">)</span><span class="token punctuation">;</span>            tx<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//提交事务</span>            ObjectNode responseNode <span class="token operator">=</span> JsonNodeFactory<span class="token punctuation">.</span>instance<span class="token punctuation">.</span><span class="token function">objectNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RpcServiceResult</span><span class="token punctuation">(</span>HttpStatus<span class="token punctuation">.</span>SC_OK<span class="token punctuation">,</span> responseNode<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>HibernateException en<span class="token punctuation">)</span> <span class="token punctuation">{</span>            tx<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"Failed to save the ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RpcServiceResult</span><span class="token punctuation">(</span>HttpStatus<span class="token punctuation">.</span>SC_INTERNAL_SERVER_ERROR<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> en<span class="token punctuation">)</span> <span class="token punctuation">{</span>            logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"Failed to save the ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            tx<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RpcServiceResult</span><span class="token punctuation">(</span>HttpStatus<span class="token punctuation">.</span>SC_INTERNAL_SERVER_ERROR<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            session<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>使用此方法批量提交插入操作，不仅可以提高效率，也可以防止SQL注入, 同时UPDATE, DELETE 等操作也可以使用此方式.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Jdbc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>storm安装教程</title>
      <link href="/2018/10/31/storm%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
      <url>/2018/10/31/storm%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>hello 小姐姐！this is my page for you. good afternoon.</p><a id="more"></a><p><img src="/images/mine.jpg" alt=""></p><blockquote><p>一盏灯， 一片昏黄； <strong>一简书</strong>， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Storm </category>
          
          <category> storm 安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> storm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring-transactional-事务理解和使用</title>
      <link href="/2018/10/29/Spring-transactional-%E4%BA%8B%E5%8A%A1/"/>
      <url>/2018/10/29/Spring-transactional-%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<hr><h3 id="SPRING-transactional-简介"><a href="#SPRING-transactional-简介" class="headerlink" title="SPRING transactional 简介"></a>SPRING transactional 简介</h3><blockquote><p>事务管理是企业级应用程序开发中必不可少的技术，用来确保数据的完整性和一致性。<br>事务就是一系列的动作，它们被当作一个单独的工作单元，这些动作要么全部完成，要么全部不起作用.</p></blockquote><h3 id="事务的四个关键属性-ACID"><a href="#事务的四个关键属性-ACID" class="headerlink" title="事务的四个关键属性(ACID)"></a>事务的四个关键属性(ACID)</h3><blockquote><p>① 原子性(atomicity):事务是一个原子操作，有一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用.<br>② 一致性(consistency):一旦所有事务动作完成，事务就被提交。数据和资源就处于一种满足业务规则的一致性状态中.<br>③ 隔离性(isolation):可能有许多事务会同时处理相同的数据，因此每个事物都应该与其他事务隔离开来，防止数据损坏.<br>④ 持久性(durability):一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响。通常情况下，事务的结果被写到持久化存储器中.<br><a id="more"></a></p></blockquote><h3 id="事务回滚的触发机制"><a href="#事务回滚的触发机制" class="headerlink" title="事务回滚的触发机制"></a>事务回滚的触发机制</h3><h4 id="transaction注解"><a href="#transaction注解" class="headerlink" title="@transaction注解"></a>@transaction注解</h4><pre class=" language-java"><code class="language-java">    This annotation type is generally directly comparable to Spring's    <span class="token punctuation">{</span><span class="token annotation punctuation">@link</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>transaction<span class="token punctuation">.</span>interceptor<span class="token punctuation">.</span>RuleBasedTransactionAttribute<span class="token punctuation">}</span>    <span class="token keyword">class</span><span class="token punctuation">,</span> and in fact <span class="token punctuation">{</span><span class="token annotation punctuation">@link</span> AnnotationTransactionAttributeSource<span class="token punctuation">}</span> will directly    convert the data to the latter <span class="token keyword">class</span><span class="token punctuation">,</span> so that Spring's transaction support code    does not have to know about annotations<span class="token punctuation">.</span> If no rules are relevant to the exception<span class="token punctuation">,</span>    it will be treated like    <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">{</span><span class="token annotation punctuation">@link</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>transaction<span class="token punctuation">.</span>interceptor<span class="token punctuation">.</span>DefaultTransactionAttribute<span class="token punctuation">}</span>    <span class="token punctuation">(</span>rolling back on <span class="token punctuation">{</span><span class="token annotation punctuation">@link</span> RuntimeException<span class="token punctuation">}</span> and <span class="token punctuation">{</span><span class="token annotation punctuation">@link</span> Error<span class="token punctuation">}</span> but not on checked    exceptions<span class="token punctuation">)</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">.</span></code></pre><blockquote><p>星号包裹部分明确指出：事务<strong>默认</strong>会在runtimeException 和 error 回滚，但是checked exception 不会回滚.</p></blockquote><h3 id="checked-exception-和-unchecked-exception"><a href="#checked-exception-和-unchecked-exception" class="headerlink" title="checked exception 和 unchecked exception"></a>checked exception 和 unchecked exception</h3><blockquote><p>1.CheckedException已检查异常，CheckedException继承自Exception，程序内部无法控制，必须做处理，要么使用try-atch块捕获，要么throws抛给上一层。<br>正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。<br>除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，<br>也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</p></blockquote><blockquote><p>2.UnCheckedException未检查异常 ，UnCheckedException继承自RuntimeException，一般是程序的逻辑问题引起的异常，不需要捕获，也不需要处理, 比如空指针异常等。<br>包括运行时异常（RuntimeException与其子类）和错误（Error）。<br>运行时异常：都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，<br>这些异常是不检查异常，程序中可以选择捕&gt;获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。<br>运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。<br>非运行时异常 （编译异常）：是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。<br>如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p></blockquote><h3 id="异常的继承结构"><a href="#异常的继承结构" class="headerlink" title="异常的继承结构"></a>异常的继承结构</h3><p><img src="/images/exception.png" alt=""></p><blockquote><p>当方法抛出runtimeException 或者error时 事务会回滚.</p></blockquote><h3 id="如何在事务回滚前trycatch异常，处理后再回滚呢，可以尝试下面的这三种方式"><a href="#如何在事务回滚前trycatch异常，处理后再回滚呢，可以尝试下面的这三种方式" class="headerlink" title="如何在事务回滚前trycatch异常，处理后再回滚呢，可以尝试下面的这三种方式"></a>如何在事务回滚前trycatch异常，处理后再回滚呢，可以尝试下面的这三种方式</h3><pre class=" language-java"><code class="language-java">   SessionFactory sessionFactory <span class="token operator">=</span> hibernateTemplate<span class="token punctuation">.</span><span class="token function">getSessionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Session session <span class="token operator">=</span> sessionFactory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Transaction tx  <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">beginTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//开启事务</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//do something</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//do something 比如记录日志</span>            <span class="token comment" spellcheck="true">//第一种方式 </span>            tx<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//手动回滚事务</span>            <span class="token comment" spellcheck="true">//第二种方式</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"runtime"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//重新抛出触发事务回滚机制的异常类 RuntimeException 或者 error</span>      <span class="token comment" spellcheck="true">//第三种方式</span>      TransactionAspectSupport<span class="token punctuation">.</span><span class="token function">currentTransactionStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setRollbackOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><h3 id="Transactional-注解也可以添加到类级别上的使用"><a href="#Transactional-注解也可以添加到类级别上的使用" class="headerlink" title="@Transactional 注解也可以添加到类级别上的使用"></a>@Transactional 注解也可以添加到类级别上的使用</h3><blockquote><p>当把@Transactional 注解放在类级别时，表示所有该类的公共方法都配置相同的事务属性信息。EmployeeService 的所有方法都支持事务并且是只读。<br>当类级别配置了@Transactional，方法级别也配置了@Transactional时，应用程序会以方法级别的事务属性信息来管理事务。</p></blockquote><pre class=" language-java"><code class="language-java">  <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation<span class="token operator">=</span> Propagation<span class="token punctuation">.</span>SUPPORTS<span class="token punctuation">,</span>readOnly<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">)</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation<span class="token operator">=</span> Propagation<span class="token punctuation">.</span>REQUIRED<span class="token punctuation">,</span>readOnly<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//方法级别的事务属性信息会覆盖类级别的相关配置信息。</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation<span class="token operator">=</span> Propagation<span class="token punctuation">.</span>REQUIRED<span class="token punctuation">,</span>readOnly<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><h3 id="Spring-的注解方式的事务实现机制"><a href="#Spring-的注解方式的事务实现机制" class="headerlink" title="Spring 的注解方式的事务实现机制"></a>Spring 的注解方式的事务实现机制</h3><blockquote><blockquote><p>在应用系统调用声明@Transactional 的目标方法时，Spring Framework 默认使用 AOP 代理，在代码运行时生成一个代理对象，根据@Transactional 的属性配置信息，这个代理对象决定该声明@Transactional 的目标方法是否由拦截器 TransactionInterceptor 来使用拦截，在 TransactionInterceptor 拦截时，会在在目标方法开始执行之前创建并加入事务，并执行目标方法的逻辑, 最后根据执行情况是否出现异常，利用抽象事务管理器(图 2 有相关介绍)AbstractPlatformTransactionManager 操作数据源 DataSource 提交或回滚事务<br>Spring AOP 代理有 CglibAopProxy 和 JdkDynamicAopProxy 两种，图 1 是以 CglibAopProxy 为例，对于 CglibAopProxy，需要调用其内部类的 DynamicAdvisedInterceptor 的 intercept 方法。对于 JdkDynamicAopProxy，需要调用其 invoke 方法。<br>正如上文提到的，事务管理的框架是由抽象事务管理器 AbstractPlatformTransactionManager 来提供的，而具体的底层事务处理实现，由 PlatformTransactionManager 的具体实现类来实现，如事务管理器 DataSourceTransactionManager。不同的事务管理器管理不同的数据资源 DataSource，比如 DataSourceTransactionManager 管理 JDBC 的 Connection。<br>PlatformTransactionManager，AbstractPlatformTransactionManager 及具体实现类关系如图 2 所示。</p></blockquote></blockquote><h3 id="transactional-的属性和使用"><a href="#transactional-的属性和使用" class="headerlink" title="transactional 的属性和使用"></a>transactional 的属性和使用</h3><blockquote><p>name    当在配置文件中有多个 TransactionManager , 可以用该属性指定选择哪个事务管理器。<br>propagation    事务的传播行为，默认值为 REQUIRED。<br>isolation    事务的隔离度，默认值采用 DEFAULT。<br>timeout    事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。<br>read-only    指定事务是否为只读事务，默认值为 false；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。<br>rollback-for    用于指定能够触发事务回滚的异常类型，如果有多个异常类型需要指定，各类型之间可以通过逗号分隔。<br>no-rollback- for    抛出 no-rollback-for 指定的异常类型，不回滚事务。</p></blockquote><h4 id="正确的设置-Transactional-的-propagation-属性"><a href="#正确的设置-Transactional-的-propagation-属性" class="headerlink" title="正确的设置@Transactional 的 propagation 属性"></a>正确的设置@Transactional 的 propagation 属性</h4><blockquote><blockquote><p>需要注意下面三种 propagation 可以不启动事务。本来期望目标方法进行事务管理，但若是错误的配置这三种 propagation，事务将不会发生回滚。<br>1 TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。<br>2 TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。<br>3 TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。</p></blockquote></blockquote><h4 id="正确的设置-Transactional-的-rollbackFor-属性"><a href="#正确的设置-Transactional-的-rollbackFor-属性" class="headerlink" title="正确的设置@Transactional 的 rollbackFor 属性"></a>正确的设置@Transactional 的 rollbackFor 属性</h4><pre class=" language-java"><code class="language-java"> <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation<span class="token operator">=</span> Propagation<span class="token punctuation">.</span>REQUIRED<span class="token punctuation">,</span>rollbackFor<span class="token operator">=</span> MyException<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span></code></pre><blockquote><p>默认情况下，如果在事务中抛出了未检查异常（继承自 RuntimeException 的异常）或者 Error，则 Spring 将回滚事务；除此之外，Spring 不会回滚事务。<br>如果在事务中抛出其他类型的异常，并期望 Spring 能够回滚事务，可以指定 rollbackFor。<br>通过分析 Spring 源码可以知道，若在目标方法中抛出的异常是 rollbackFor 指定的异常的子类，事务同样会回滚。</p></blockquote><h3 id="Transactional-和aop"><a href="#Transactional-和aop" class="headerlink" title="Transactional 和aop"></a>Transactional 和aop</h3><p>只有@Transactional 注解应用到 public 方法，才能进行事务管理。这是因为在使用 Spring AOP 代理时，Spring 在调用在图 1 中的 TransactionInterceptor 在目标方法执行前后进行拦截之前，DynamicAdvisedInterceptor（CglibAopProxy 的内部类）的的 intercept 方法或 JdkDynamicAopProxy 的 invoke 方法会间接调用 AbstractFallbackTransactionAttributeSource（Spring 通过这个类获取表 1. @Transactional 注解的事务属性配置属性信息）的 computeTransactionAttribute 方法。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> TransactionAttribute <span class="token function">computeTransactionAttribute</span><span class="token punctuation">(</span>Method method<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> targetClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Don't allow no-public methods as required.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">allowPublicMethodsOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>Modifier<span class="token punctuation">.</span><span class="token function">isPublic</span><span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>这个方法会检查目标方法的修饰符是不是 public，若不是 public，就不会获取@Transactional 的属性配置信息，最终会造成不会用 TransactionInterceptor 来拦截该目标方法进行事务管理。</p></blockquote><h4 id="如何解决AOP事务失效问题"><a href="#如何解决AOP事务失效问题" class="headerlink" title="如何解决AOP事务失效问题"></a>如何解决AOP事务失效问题</h4><blockquote><p>在 Spring 的 AOP 代理下，只有目标方法由外部调用，目标方法才由 Spring 生成的代理对象来管理，这会造成自调用问题。若同一类中的其他没有@Transactional 注解的方法内部调用有@Transactional 注解的方法，有@Transactional 注解的方法的事务被忽略，不会发生回滚<br><code>`</code>java<br>@Service<br>public class OrderService {<br>    private void insert() {<br>      insertOrder();<br>    }</p></blockquote><p>@Transactional<br>    public void insertOrder() {<br>        //do something<br>     }<br>}</p><pre><code>&gt;insertOrder 尽管有@Transactional 注解，但它被内部方法 insert 调用，事务被忽略，出现异常事务不会发生回滚。上面的两个问题@Transactional 注解只应用到 public 方法和自调用问题，是由于使用 Spring AOP 代理造成的。为解决这两个问题，使用 AspectJ 取代 Spring AOP 代理。#### 解决办法&gt;1 添加ASPECTJ XML配置``` XML  &lt;tx:annotation-driven mode=&quot;aspectj&quot; /&gt;  &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;  &lt;/bean&gt;  &lt;/bean  class=&quot;org.springframework.transaction.aspectj.AnnotationTransactionAspect&quot; factory-method=&quot;aspectOf&quot;&gt;    &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot; /&gt;  &lt;/bean&gt;</code></pre><blockquote><p>2 同时在 Maven 的 pom 文件中加入 spring-aspects 和 aspectjrt 的 dependency 以及 aspectj-maven-plugin。<br><code>`</code> XML</p></blockquote><p><dependency><br>  <groupid>org.springframework</groupid><br>  <artifactid>spring-aspects</artifactid><br>  <version>4.3.2.RELEASE</version><br></dependency></p><p><dependency><br>  <groupid>org.aspectj</groupid><br>  <artifactid>aspectjrt</artifactid><br>  <version>1.8.9</version><br></dependency></p><p><plugin></plugin></p><p><groupid>org.codehaus.mojo</groupid></p><p><artifactid>aspectj-maven-plugin</artifactid></p><p><version>1.9</version></p><p><configuration></configuration></p><p><showweaveinfo>true</showweaveinfo></p><p><aspectlibraries><br>  <aspectlibrary><br>    <groupid>org.springframework</groupid><br>    <artifactid>spring-aspects</artifactid><br>  </aspectlibrary><br></aspectlibraries><br></p><p><executions><br>  <execution><br>  <goals><br>    <goal>compile</goal><br>    <goal>test-compile</goal><br>  </goals><br>  </execution><br></executions><br><br><code>`</code></p><hr><p><a href="https://www.ibm.com/developerworks/cn/java/j-master-spring-transactional-use/index.html" target="_blank" rel="noopener">参考https://www.ibm.com/developerworks/cn/java/j-master-spring-transactional-use/index.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Transaction </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Thread-pool-多线程并发</title>
      <link href="/2018/10/29/Thread-pool-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/"/>
      <url>/2018/10/29/Thread-pool-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h3 id="多线程简介"><a href="#多线程简介" class="headerlink" title="多线程简介"></a>多线程简介</h3><blockquote><p>多线程适合多种开发语言的开发, 这是一种思想，基于的是操作系统底层的CPU调度.<br>  此篇介绍线程、多线程、和线程池的使用和机制。<br><a id="more"></a></p></blockquote><h3 id="进程-线程"><a href="#进程-线程" class="headerlink" title="进程\线程"></a>进程\线程</h3><ol><li>进程<blockquote><p>1 进程 是指在系统中正在运行的一个应用程序, 每一个进程都有一个PID， 当进程占用太多资源或者卡死的时候，CPU会强杀掉进程。<br>2 每个进程之间是独立的，每个进程均运行在其专用的且受保护的内存空间内。</p></blockquote></li><li>线程<blockquote><p>1 个进程由多个线程组成(1个进程至少要有1个线程)。<br>2 线程是进程的基本执行单元，一个进程的所有任务都在线程中执行。</p></blockquote></li></ol><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><ol><li>多线程<blockquote><p>1个进程中可以开启多个线程，多个线程可以同时执行不同的任务, 多线程一般情况下可以提高程序的执行效率。</p></blockquote></li><li>多线程原理<blockquote><p>对于单核CPU来说，同一时间，CPU只能处理1个线程，只有1个线程正在执行，现在大部分CPU都是4核8线程。<br>   多线程同时执行的本质：是CPU快速的在多个线程之间的切换，这个时间非常的短在毫秒级别，以至于用户无法察觉。<br>   CPU调度线程的时间足够快，就造成了多线程的“同时”执行。<br>   如果线程数非常多，CPU会在n个线程之间切换，消耗大量的CPU资源，每个线程被调度的次数会降低，线程的执行效率降低。</p></blockquote></li><li>多线程的优点<blockquote><p>能适当提高程序的执行效率，但是在业务简单时，单线程会比多线程更快。<br>  能适当提高资源的利用率(CPU、内存)。<br>  线程上的任务执行完成后，线程会自动销毁。</p></blockquote></li><li>多线程的缺点<blockquote><p>开启线程需要占用一定的内存空间(默认情况下，每一个线程都占用512KB)，如果开启大量的线程，会占用大量的内存空间，降低程序的性能。<br>  线程越多，CPU在调用线程上的开销就越大。<br>  程序设计更加复杂，比如线程间的通信、多线程的数据共享。</p></blockquote></li><li>主线程<blockquote><p>一个程序运行后，默认会开启1个线程，称为“主线程”或“UI线程”，java中的main方法就是一个程序的主线程，如果这个方法体中的业务逻辑存在while循环、线程池<br> 、websorcket等阻塞程序的，那么会使main方法阻塞，程序则不会退出，这也是程序正常运行不退出的原因；一些简单类的main方法会退出是因为并没有阻塞main方法。<br> 主线程一般用来刷新UI界面，处理UI事件。<br> 主线程使用注意：别将耗时的操作放到主线程中，因为耗时操作会卡住主线程，严重影响UI的流畅度，给用户一种卡的坏体验。</p></blockquote></li></ol><h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><ol><li>同步执行<blockquote><p>写程序的时候都是从上到下，从左到右，代码执行顺序也是从上到下从右到左。<br> 1个线程执行多个任务，也是依次执行a-&gt;b-&gt;c。<br> 1个线程同一时间执行1个任务。</p></blockquote></li><li>异步执行<blockquote><p>多个线程可以同时执行多个任务。<br>  多个线程执行多个任务可以同时执行a，b，c。</p></blockquote></li><li>synchronized<blockquote><p>同步块大家都比较熟悉，通过 synchronized 关键字来实现；所有加上 synchronized 的方法和块语句，在多线程访问的时候，同一时刻只能有一个线程能够访问。</p></blockquote></li><li>wait()、notify()、notifyAll()<blockquote><p>这三个方法是 java.lang.Object 的 final native 方法，任何继承 java.lang.Object 的类都有这三个方法。<br>  它们是Java语言提供的实现线程间阻塞和控制进程内调度的底层机制，平时我们会很少用到的。</p></blockquote></li><li>wait()：<blockquote><p>导致线程进入等待状态，直到它被其他线程通过notify()或者notifyAll唤醒，该方法只能在同步方法中调用。</p></blockquote></li><li>notify()：<blockquote><p>随机选择一个在该对象上调用wait方法的线程，解除其阻塞状态，该方法只能在同步方法或同步块内部调用。</p></blockquote></li><li>notifyAll()：<blockquote><p>解除所有那些在该对象上调用wait方法的线程的阻塞状态，同样该方法只能在同步方法或同步块内部调用。<br>  调用这三个方法中任意一个，当前线程必须是锁的持有者，如果不是会抛出一个 IllegalMonitorStateException 异常。</p></blockquote></li><li>wait()与Thread.sleep(long time)的区别<blockquote><p>sleep()   ：方法在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），该线程不丢失任何监视器的所属权，sleep() 是 Thread 类专属的静态方法，针对一个特定的线程。<br>  wait()    : 方法使实体所处线程暂停执行，从而使对象进入等待状态，直到被 notify() 方法通知或者 wait() 的等待的时间到。<br>  sleep()   : 方法使持有的线程暂停运行，从而使线程进入休眠状态，直到用interrupt 方法来打断他的休眠或者 sleep 的休眠的时间到。<br>  wait()    : 方法进入等待状态时会释放同步锁，而 sleep() 方法不会释放同步锁。所以，当一个线程无限 sleep 时又没有任何人去 interrupt 它的时候，程序就产生大麻烦了。<br>  notify()  : 是用来通知线程，但在 notify() 之前线程是需要获得 lock 的。另个意思就是必须写在 synchronized(lockobj) {…} 之中。<br>  wait()    : 也是这个样子，一个线程需要释放某个 lock，也是在其获得 lock 情况下才能够释放，所以 wait() 也需要放在 synchronized(lockobj) {…} 之中。</p></blockquote></li><li>volatile 关键字<blockquote><p>volatile 是一个特殊的修饰符，只有成员变量才能使用它。在Java并发程序缺少同步类的情况下，多线程对成员变量的操作对其它线程是透明的。<br>  volatile 变量可以保证下一个读取操作会在前一个写操作之后发生。线程都会直接从内存中读取该变量并且不缓存它。这就确保了线程读取到的变量是同内存中是一致的。</p></blockquote></li><li>ThreadLocal 变量<blockquote><p>ThreadLocal 是Java里一种特殊的变量。每个线程都有一个 ThreadLocal 就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。<br>  如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。首先，通过复用减少了代价高昂的对象的创建个数。<br>  其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。</p></blockquote></li><li><p>Join() 方法</p><blockquote><p>join() 方法定义在 Thread 类中，所以调用者必须是一个线程，join() 方法主要是让调用该方法的 Thread 完成 run() 方法里面的东西后，再执行 join() 方法后面的代码。</p></blockquote><pre class=" language-java"><code class="language-java">    Thread t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>计数线程一<span class="token punctuation">)</span><span class="token punctuation">;</span>      Thread t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>计数线程二<span class="token punctuation">)</span><span class="token punctuation">;</span>      t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 等待计数线程一执行完成，再执行计数线程二</span>    t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre><blockquote><p>启动 t1 后，调用了 join() 方法，直到 t1 的计数任务结束，才轮到 t2 启动，然后 t2 才开始计数任务，两个线程是按着严格的顺序来执行的。<br>  如果 t2 的执行需要依赖于 t1 中的完整数据的时候，这种方法就可以很好的确保两个线程的同步性。</p></blockquote></li><li>Thread.yield() 方法<blockquote><p>Thread.sleep(long time)：线程暂时终止执行（睡眠）一定的时间。<br>  Thread.yield()：线程放弃运行，将CPU的控制权让出。<br>  这两个方法都会将当前运行线程的CPU控制权让出来，但 sleep() 方法在指定的睡眠时间内一定不会再得到运行机会，直到它的睡眠时间完成；<br>  而 yield() 方法让出控制权后，还有可能马上被系统的调度机制选中来运行，比如，执行yield()方法的线程优先级高于其他的线程，那么这个线程即使执行了 yield() 方法也可能不能起到让出CPU控制权的效果，因为它让出控制权后，进入排队队列，调度机制将&gt;从等待运行的线程队列中选出一个等级最高的线程来运行，那么它又（很可能）被选中来运行。</p></blockquote></li></ol><h3 id="Java-多线程的实现的三种方式"><a href="#Java-多线程的实现的三种方式" class="headerlink" title="Java 多线程的实现的三种方式"></a>Java 多线程的实现的三种方式</h3><ol><li>继承thread方式<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">newThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//do something</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//do something</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>Thread 类中的 start() 和 run() 方法有什么区别<br>调用 start() 方法才会启动新线程；如果直接调用 Thread 的 run() 方法，它的行为就会和普通的方法一样；为了在新的线程中执行我们的代码，必须使用 Thread.start() 方法。</p></blockquote></li><li>实现runable接口方式<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NewThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//do something</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li>继承thread其实也是实现runable接口的方式实现的<br><img src="/images/thread.png" alt=""></li><li><p>实现callable接口</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NewCallableThread</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//String 是线程的返回值类型</span>    <span class="token keyword">private</span> String threadName<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Object obj<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">NewCallableThread</span><span class="token punctuation">(</span>String threadName<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">,</span> Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>threadName <span class="token operator">=</span> threadName<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> count<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>obj   <span class="token operator">=</span> obj<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>count <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                count <span class="token operator">++</span><span class="token punctuation">;</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>threadName <span class="token operator">+</span> <span class="token string">">count>"</span> <span class="token operator">+</span> count <span class="token operator">+</span><span class="token string">"object is "</span> <span class="token operator">+</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token string">"这是返回值"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//callable接口可以返回线程的执行结果,也可以抛出异常，例如此线程处理完的数据结果可返回给调用者，但是线程不会释放资源直到拿到返回值，所以如果不需要返回return null即可</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        NewCallableThread thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NewCallableThread</span><span class="token punctuation">(</span><span class="token string">"thread1"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        thread1<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        NewCallableThread thread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NewCallableThread</span><span class="token punctuation">(</span><span class="token string">"thread2"</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread2<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>单线程和多线程演示</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NewThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String threadName<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Object obj<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//obj 是任何类型的可将此对象传入线程中使用</span>    <span class="token keyword">public</span> <span class="token function">NewThread</span><span class="token punctuation">(</span>String threadName<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">,</span> Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>threadName <span class="token operator">=</span> threadName<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> count<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>obj   <span class="token operator">=</span> obj<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>count <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                count <span class="token operator">++</span><span class="token punctuation">;</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>threadName <span class="token operator">+</span> <span class="token string">">count>"</span> <span class="token operator">+</span> count <span class="token operator">+</span><span class="token string">"object is "</span> <span class="token operator">+</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        NewThread thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NewThread</span><span class="token punctuation">(</span><span class="token string">"thread1"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        thread1<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        NewThread thread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NewThread</span><span class="token punctuation">(</span><span class="token string">"thread2"</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread2<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>thread1、thread2都是单独的一个线程,都是由CPU调度执行</p></blockquote></li><li><p>附runable和callable的接口源码</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token punctuation">{</span>     V <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>runable和callable的对比</p><blockquote><p>Callable 接口下的方法是 call()，Runnable 接口的方法是 run()。<br>   Callable 的任务执行后可返回值，而 Runnable 的任务是不能返回值的。<br>   call() 方法可以抛出异常，run()方法不可以的。<br>   运行 Callable 任务可以拿到一个 Future 对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。<br>   通过 Future 对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。</p></blockquote></li><li><p>附future接口的源码</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Future</span><span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token punctuation">{</span>     <span class="token keyword">boolean</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> mayInterruptIfRunning<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">boolean</span> <span class="token function">isCancelled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">boolean</span> <span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     V <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span> ExecutionException<span class="token punctuation">;</span>     V <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span> ExecutionException<span class="token punctuation">,</span> TimeoutException<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><blockquote><p>boolean cancel(boolean mayInterruptIfRunning);<br>   此方法试图取消对此任务的执行。<strong>[任务已完成、已取消，或者由于某些其他原因而无法取消，则此尝试将失败，cancel调用成功后，isCancelled和isDone将始终返回true]</strong>，<br>   mayInterruptIfRunning 参数确定是否应该使用试图停止任务的方式来中断执行此任务的线程</p></blockquote><blockquote><p>boolean isCancelled(); 如果在任务正常完成前将其取消，则返回 true</p></blockquote><blockquote><p>boolean isDone(); 任务是否已完成</p></blockquote><blockquote><p>V get() throws InterruptedException, ExecutionException; 如有必要等待线程执行完毕，获取返回结果</p></blockquote><blockquote><p>V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; 在规定时间内等待线程执行完毕，获取返回结果</p></blockquote></li><li><p>FutureTask-Thread的设计优化</p><pre class=" language-java"><code class="language-java">     <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">RunnableFuture</span><span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token punctuation">{</span>         <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">RunnableFuture</span><span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Runnable</span><span class="token punctuation">,</span> Future<span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token punctuation">{</span>         <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span></code></pre><blockquote><p>FutureTask 实现了 Runnable 和 Future，所以兼顾两者优点，既可以在 Thread 中使用，又可以在 ExecutorService 中使用。</p></blockquote><pre class=" language-java"><code class="language-java">     Callable<span class="token operator">&lt;</span>String<span class="token operator">></span> callable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token annotation punctuation">@Override</span>         <span class="token keyword">public</span> String <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>             <span class="token keyword">return</span> <span class="token string">"something"</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span><span class="token punctuation">;</span>     FutureTask<span class="token operator">&lt;</span>String<span class="token operator">></span> task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span>callable<span class="token punctuation">)</span><span class="token punctuation">;</span>     Thread t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>     t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 启动线程</span>     task<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 取消线程</span></code></pre><blockquote><p>使用 FutureTask 的好处是 FutureTask 弥补了Thread 的不足，它可以让调用者准确地知道线程什么时候执行完成并获得线程执行完成后的返回结果。<br>FutureTask 是一种可以取消的异步的计算任务，它的计算是通过 Callable 实现的，它等价于可以携带结果的 Runnable，并且有三个状态：等待、运行和完成。<br>完成包括所有计算以任意的方式结束，包括正常结束、取消和异常。</p></blockquote></li></ol><hr><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ol><li>线程池简介<blockquote><p>Java里面线程池的顶级接口是 Executor，不过真正的线程池接口是 ExecutorService， ExecutorService 的默认实现是 ThreadPoolExecutor；<br>   普通类 Executors 里面调用的就是 ThreadPoolExecutor。</p></blockquote></li><li><p>线程池的优点</p><blockquote><p>1 避免线程的创建和销毁带来的性能开销。<br>   2 避免大量的线程间因互相抢占系统资源导致的阻塞现象。<br>   3 能够对线程进行简单的管理并提供定时执行、间隔执行等功能。</p></blockquote></li><li><p>如何初始化一个线程池</p><pre class=" language-java"><code class="language-java">     <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NewPool</span> <span class="token punctuation">{</span>         <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> corePoolSize <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>         <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> maximumPoolSize <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>         <span class="token keyword">final</span> <span class="token keyword">static</span> BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">private</span> <span class="token keyword">static</span> ExecutorService pool <span class="token operator">=</span> null<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//初始化线程池</span>         <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">initPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>             pool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> maximumPoolSize<span class="token punctuation">,</span> 0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span> workQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//或者使用Executors创建线程池</span>             <span class="token comment" spellcheck="true">//pool = Executors.newSingleThreadExecutor();</span>             <span class="token comment" spellcheck="true">//pool = Executors.newCachedThreadPool();</span>             <span class="token comment" spellcheck="true">//pool = Executors.newFixedThreadPool(5);</span>             <span class="token comment" spellcheck="true">//pool = Executors.newScheduledThreadPool(5);</span>         <span class="token punctuation">}</span>         <span class="token comment" spellcheck="true">//当有新的数据时调用poolAddThread(String,int,Object obj)处理传入的数据，</span>         <span class="token comment" spellcheck="true">//例如如obj, object就相当于数据</span>         <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">poolAddThread</span><span class="token punctuation">(</span>String threadName<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">,</span> Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>             NewThread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NewThread</span><span class="token punctuation">(</span>threadName<span class="token punctuation">,</span> count<span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>             pool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span>             NewCallableThread callThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NewCallableThread</span><span class="token punctuation">(</span>threadName<span class="token punctuation">,</span> count<span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>             pool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>callThread<span class="token punctuation">)</span><span class="token punctuation">;</span>             pool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>             <span class="token function">initPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span></code></pre><blockquote><p>execute 和submit的区别在于submit可以抛出异常和返回结果，给外部调用者处理，例如某一个task失败则终止其他task执行，或者shutdown线程池.</p></blockquote></li><li><p>线程池分类及比较-Executors 提供四种线程池</p><blockquote><p>newCachedThreadPool<br>   可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。<br>   调用 execute() 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中,<br>   终止并从缓存中移除那些已有 60 秒钟未被使用的线程。<br>   因此，长时间保持空闲的线程池不会使用任&gt;何资源。注意，可以使用 ThreadPoolExecutor 构造方法创建具有类似属性但细节不同（例如超时参数）的线程池。</p></blockquote><blockquote><p>newSingleThreadExecutor<br>   创建一个单线程池，也就是该线程池只有一个线程在工作，所有的任务是串行执行的，如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它，<br>   此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p></blockquote><blockquote><p>newFixedThreadPool<br>   创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小，线程池的大小一旦达到最大值就会保持不变，<br>   如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</p></blockquote><blockquote><p>newScheduledThreadPool<br>   创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。</p></blockquote><pre class=" language-java"><code class="language-java">     <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Executor</span> <span class="token punctuation">{</span>         <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ExecutorService</span> <span class="token keyword">extends</span> <span class="token class-name">Executor</span> <span class="token punctuation">{</span>         <span class="token keyword">void</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         List<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> <span class="token function">shutdownNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">boolean</span> <span class="token function">isShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">boolean</span> <span class="token function">isTerminated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token operator">&lt;</span>T<span class="token operator">></span> Future<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">submit</span><span class="token punctuation">(</span>Callable<span class="token operator">&lt;</span>T<span class="token operator">></span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token operator">&lt;</span>T<span class="token operator">></span> Future<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">submit</span><span class="token punctuation">(</span>Runnable task<span class="token punctuation">,</span> T result<span class="token punctuation">)</span><span class="token punctuation">;</span>         Future<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">submit</span><span class="token punctuation">(</span>Runnable task<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Executors</span> <span class="token punctuation">{</span>         <span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                 <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span> 60L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                                  <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token comment" spellcheck="true">//...</span>     <span class="token punctuation">}</span></code></pre></li><li><p>ThreadPoolExecutor构造函数</p><pre class=" language-java"><code class="language-java">     <span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                             <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>                             <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>                             TimeUnit unit<span class="token punctuation">,</span>                             BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>                             ThreadFactory threadFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">this</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> maximumPoolSize<span class="token punctuation">,</span> keepAliveTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> workQueue<span class="token punctuation">,</span>              threadFactory<span class="token punctuation">,</span> defaultHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span></code></pre><blockquote><p>1 corePoolSize：线程池的核心线程数，一般情况下不管有没有任务都会一直在线程池中一直存活，只有在 ThreadPoolExecutor 中的方法<br>   allowCoreThreadTimeOut(boolean value) 设置为 true 时，闲置的核心线程会存在超时机制，如果在指定时间没有新任务来时，<br>   核心线程也会被终止，而这个时间间隔由第3个属性 keepAliveTime 指定。</p></blockquote><blockquote><p>2 maximumPoolSize：线程池所能容纳的最大线程数，当活动的线程数达到这个值后，后续的新任务将会被阻塞。</p></blockquote><blockquote><p>3 keepAliveTime：控制线程闲置时的超时时长，超过则终止该线程。一般情况下用于非核心线程，<br>   只有在 ThreadPoolExecutor 中的方法 allowCoreThreadTimeOut(boolean value) 设置为 true时，也作用于核心线程。</p></blockquote><blockquote><p>4 unit：用于指定 keepAliveTime 参数的时间单位，TimeUnit 是个 enum 枚举类型，常用的有：TimeUnit.HOURS(小时)、TimeUnit.MINUTES(分钟)、<br>   TimeUnit.SECONDS(秒) 和TimeUnit.MILLISECONDS(毫秒)等。</p></blockquote><blockquote><p>5 workQueue：线程池的任务队列，通过线程池的 execute(Runnable command) 方法会将任务 Runnable 存储在队列中，之后我会出一个submit和excute的详细对比。</p></blockquote><blockquote><p>6 threadFactory：线程工厂，它是一个接口，用来为线程池创建新线程的。</p></blockquote></li><li><p>线程池的关闭</p><blockquote><p>ThreadPoolExecutor 提供了两个方法，用于线程池的关闭，分别是 shutdown() 和 shutdownNow()。<br>   shutdown()：不会立即的终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务。<br>   shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务。</p></blockquote></li></ol><hr><p><a href="https://www.jianshu.com/p/b8197dd2934c" target="_blank" rel="noopener">参考https://www.jianshu.com/p/b8197dd2934c</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Thread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> pool </tag>
            
            <tag> Synchronized </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Netty-Nio</title>
      <link href="/2018/10/29/Netty-NIO-%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/10/29/Netty-NIO-%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>hello 小姐姐！this is my page for you. good afternoon.</p><a id="more"></a><p><img src="/images/mine.jpg" alt=""></p><blockquote><p>一盏灯， 一片昏黄； <strong>一简书</strong>， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nio </tag>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
